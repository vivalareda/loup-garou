This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-11T01:02:24.867Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
app/
  (tabs)/
    _layout.tsx
    CardTest.tsx
    DayVote.tsx
    Death.tsx
    GameInterface.tsx
    index.tsx
    LoveAlert.tsx
    Seer.tsx
    test-page.tsx
    TestingInterface.tsx
    waiting-room.tsx
    Werewolf.tsx
    WitchHeal.tsx
    WitchKill.tsx
  _layout.tsx
  +not-found.tsx
components/
  __tests__/
    __snapshots__/
      ThemedText-test.tsx.snap
    ThemedText-test.tsx
  roles/
    Cupidon.tsx
    Hunter.tsx
  ui/
    IconSymbol.ios.tsx
    IconSymbol.tsx
    TabBarBackground.ios.tsx
    TabBarBackground.tsx
  Collapsible.tsx
  ExternalLink.tsx
  HapticTab.tsx
  HelloWave.tsx
  ParallaxScrollView.tsx
  ThemedText.tsx
  ThemedView.tsx
constants/
  Colors.ts
  roles.ts
hooks/
  useColorScheme.ts
  useColorScheme.web.ts
  useThemeColor.ts
scripts/
  reset-project.js
utils/
  config.js
  sockets.js
.gitignore
app.json
babel.config.js
global.css
metro.config.js
nativewind-env.d.ts
notes.txt
package.json
README.md
tailwind.config.js
tsconfig.json
types.ts

================================================================
Repository Files
================================================================

================
File: app/(tabs)/_layout.tsx
================
import { Tabs } from "expo-router";
import React from "react";
import { Platform } from "react-native";

import { HapticTab } from "@/components/HapticTab";
import { IconSymbol } from "@/components/ui/IconSymbol";
import TabBarBackground from "@/components/ui/TabBarBackground";
import { Colors } from "@/constants/Colors";
import { useColorScheme } from "@/hooks/useColorScheme";

export default function TabLayout() {
  const colorScheme = useColorScheme();

  return (
    <Tabs
      screenOptions={{
        tabBarActiveTintColor: Colors[colorScheme ?? "light"].tint,
        headerShown: false,
        tabBarButton: HapticTab,
        tabBarBackground: TabBarBackground,
        tabBarStyle: Platform.select({
          ios: {
            // Use a transparent background on iOS to show the blur effect
            position: "absolute",
          },
          default: {},
        }),
      }}
    >
      <Tabs.Screen
        name="index"
        options={{
          title: "Home",
          tabBarIcon: ({ color }) => (
            <IconSymbol size={28} name="house.fill" color={color} />
          ),
        }}
      />
    </Tabs>
  );
}

================
File: app/(tabs)/CardTest.tsx
================
// Inspiration: https://dribbble.com/shots/7696045-Tarot-App-Design

import { useEffect, useState } from "react";
import { Dimensions, Image, StyleSheet, Text, View } from "react-native";
import {
  Gesture,
  GestureDetector,
  GestureHandlerRootView,
} from "react-native-gesture-handler";
import type { SharedValue } from "react-native-reanimated";
import Animated, {
  Extrapolation,
  interpolate,
  runOnJS,
  useAnimatedStyle,
  useDerivedValue,
  useSharedValue,
  withDecay,
  withSpring,
  withTiming,
} from "react-native-reanimated";
// const tarodCardImg = `https://user-images.githubusercontent.com/2805320/245194123-d1fc79fd-c8e1-48a8-b229-59b3f3ec04fb.jpg`
const tarodCardImg = `https://img.freepik.com/free-vector/hand-drawn-esoteric-pattern-design_23-2149346196.jpg?size=500&ext=jpg`;
const { width, height } = Dimensions.get("window");

const numberOfCards = 8;
type TarotCard = {
  key: string;
  uri: string;
};
const tarotCards: TarotCard[] = [...Array(numberOfCards).keys()].map((i) => ({
  key: `tarot-card-${i}`,
  uri: tarodCardImg,
}));
const minSize = 120;
const tarotCardSize = {
  width: minSize,
  height: minSize * 1.67,
  borderRadius: 12,
};
const TWO_PI = 2 * Math.PI;
const theta = (TWO_PI / numberOfCards) * 0.3;
const tarotCardSizeVisiblePercentage = 0.9;
const tarotCardSizeOnCircle =
  tarotCardSizeVisiblePercentage * tarotCardSize.width;
const circleRadius = Math.max(
  ((tarotCardSizeOnCircle * numberOfCards) / TWO_PI) * 1,
  width / 1,
);
const circleCircumference = TWO_PI * circleRadius;

// We can also extract x,y based on theta and radius, I am leaving the code here
// but we are going to use a different hack. which is, we are going to make the
// tarod card wrapper height the circle diameter, so that we can use just the
// rotate with `theta * index`, because the transform origin will be the middle
// of the circle and the rotation will work perfectly.
const x = (index: number) => Math.cos(theta) * index * circleRadius;
const y = (index: number) => Math.sin(theta) * index * circleRadius;
const changeFactor = circleCircumference / width;

function TarotCard({
  card,
  cardIndex,
  index,
  activeIndex,
}: {
  card: TarotCard;
  index: SharedValue<number>;
  cardIndex: number;
  activeIndex: SharedValue<number>;
}) {
  const mounted = useSharedValue(0);
  const flip = useSharedValue(0);

  useEffect(() => {
    mounted.value = withTiming(1, { duration: 500 });
  }, []);

  const handleFlip = () => {
    flip.value = flip.value === 0 ? 1 : 0;
  };

  const frontAnimatedStyle = useAnimatedStyle(() => {
    const rotation = interpolate(flip.value, [0, 1], [0, 180]);
    return {
      transform: [{ rotateY: withTiming(`${rotation}deg`, { duration: 500 }) }],
    };
  });

  const backAnimatedStyle = useAnimatedStyle(() => {
    const rotation = interpolate(flip.value, [0, 1], [180, 360]);
    return {
      transform: [{ rotateY: withTiming(`${rotation}deg`, { duration: 500 }) }],
    };
  });

  const stylez = useAnimatedStyle(() => {
    const isActive = activeIndex.value === cardIndex;
    const offset = isActive ? -tarotCardSize.height / 2 : 0;

    return {
      transform: [
        {
          rotate: `${interpolate(
            mounted.value,
            [0, 1],
            [0, theta * cardIndex],
          )}rad`,
        },
        { translateY: withSpring(offset) },
      ],
    };
  });

  return (
    <Animated.View
      style={[
        {
          width: tarotCardSize.width,
          height: circleRadius * 2,
          position: "absolute",
          shadowColor: "#000",
          shadowOffset: { width: 0, height: 1 },
          shadowOpacity: 0.3,
          shadowRadius: 4,
          elevation: 4,
        },
        stylez,
      ]}
    >
      <Animated.View
        style={[frontAnimatedStyle, { backfaceVisibility: "hidden" }]}
        className="absolute  w-full bg-gray-200 rounded-lg justify-center items-center"
      >
        <Image
          key={card.key}
          source={{ uri: card.uri }}
          style={styles.tarotCardBackImage}
        />
      </Animated.View>

      <Animated.View
        style={[backAnimatedStyle, { backfaceVisibility: "hidden" }]}
        className="absolute h-full w-full bg-red-400 rounded-lg justify-center items-center"
      >
        <Text className="text-xl font-bold text-center">Backside Content</Text>
      </Animated.View>

      <Text
        onPress={handleFlip}
        style={{
          position: "absolute",
          bottom: -20,
          color: "white",
          fontWeight: "700",
        }}
      >
        Flip
      </Text>
    </Animated.View>
  );
}

function TarotWheel({
  cards,
  onCardChange,
}: {
  cards: TarotCard[];
  onCardChange: (cardIndex: number) => void;
}) {
  const distance = useSharedValue(0);
  const angle = useDerivedValue(() => {
    return distance.value / circleCircumference;
  });
  const interpolatedIndex = useDerivedValue(() => {
    const x = Math.abs((angle.value % TWO_PI) / theta);
    return angle.value < 0 ? x : numberOfCards - x;
  });
  const activeIndex = useDerivedValue(() => {
    const index = Math.round(interpolatedIndex.value) % numberOfCards;
    const result = index < 0 ? numberOfCards + index : index;
    console.log("activeIndex calculated:", result);
    return result;
  });

  const pan = Gesture.Pan()
    .onChange((ev) => {
      const nextAngle =
        angle.value + (ev.changeX * changeFactor) / circleCircumference;
      const nextIndex = Math.abs((nextAngle % TWO_PI) / theta);
      const nextActiveIndex =
        nextAngle < 0 ? nextIndex : numberOfCards - nextIndex;

      if (nextActiveIndex >= 0 && nextActiveIndex < numberOfCards) {
        distance.value += ev.changeX * changeFactor;
      }
    })
    .onFinalize((ev) => {
      distance.value = withDecay(
        {
          velocity: ev.velocityX,
          velocityFactor: changeFactor,
          deceleration: 0.998,
        },
        () => {
          const v = numberOfCards - activeIndex.value;
          const newAngleFloat = -interpolatedIndex.value * theta;
          const newAngle = -activeIndex.value * theta;
          // Snap to the closest interpolated index and than animate to the actual slide.
          // This is because we would like to "fake" the snap and avoid rotating the entire
          // circle in case when moving from positive to negative (and viceversa) angles.
          // If we are using directly the withSpring animation, this will look awful, because
          // we will move from let's say from -circleCircumference / 2 to  +circleCircumference / 4
          // the animation will be really fast because it should rotate the circle 275 degrees
          // So the below math equation will actually position the distance exactly where it is so that
          // the distance it's directly changed (using the float index value) and than start the spring
          // animation
          distance.value = newAngleFloat * circleCircumference;
          distance.value = withSpring(newAngle * circleCircumference);
          runOnJS(onCardChange)(activeIndex.value);
        },
      );
    });

  const stylez = useAnimatedStyle(() => {
    return {
      transform: [
        {
          rotate: `${angle.value}rad`,
        },
      ],
    };
  });
  return (
    <GestureDetector gesture={pan}>
      <Animated.View
        style={[
          {
            width: circleRadius * 2,
            height: circleRadius * 2,
            position: "absolute",
            justifyContent: "center",
            alignItems: "center",
            alignSelf: "center",
            bottom: -circleRadius,
            top: height - tarotCardSize.height * 1.5,
          },
          stylez,
        ]}
      >
        {cards.map((card, cardIndex) => (
          <TarotCard
            card={card}
            key={card.key}
            index={interpolatedIndex}
            cardIndex={cardIndex}
            activeIndex={activeIndex}
          />
        ))}
      </Animated.View>
    </GestureDetector>
  );
}

export default function TarotCards() {
  const [activeCardIndex, setActiveCardIndex] = useState<null | number>(null);
  return (
    <GestureHandlerRootView>
      <View
        style={{
          flex: 1,
          justifyContent: "center",
          alignItems: "center",
          backgroundColor: "#164aa1",
        }}
      >
        {activeCardIndex !== null && (
          <Text
            style={{
              position: "absolute",
              top: 100,
              color: "white",
              fontWeight: "700",
            }}
          >
            Selected card: {activeCardIndex}
          </Text>
        )}
        <TarotWheel
          cards={tarotCards}
          onCardChange={(cardIndex) => setActiveCardIndex(cardIndex)}
        />
      </View>
    </GestureHandlerRootView>
  );
}

const styles = StyleSheet.create({
  tarotCardBackImage: {
    width: tarotCardSize.width,
    height: tarotCardSize.height,
    borderRadius: tarotCardSize.borderRadius,
    resizeMode: "repeat",
    borderWidth: 4,
    borderColor: "white",
  },
});

================
File: app/(tabs)/DayVote.tsx
================
import React, { useEffect, useState } from "react";
import { useRouter } from "expo-router";
import {
  SafeAreaView,
  Text,
  Button,
  FlatList,
  TouchableOpacity,
  View,
  Alert,
} from "react-native";
import axios from "axios";
import { socket } from "@/utils/sockets";
import { Player } from "../../types";
import { backendUrl } from "@/utils/config";
import { useLocalSearchParams } from "expo-router";
import { useFocusEffect } from "@react-navigation/native";

const DayVote = () => {
  const router = useRouter();
  const { player: playerString } = useLocalSearchParams() as { player: string };
  const [player, setPlayer] = useState<Player>(JSON.parse(playerString));
  const [playerSelection, setPlayerSelection] = useState<
    { name: string; sid: string }[]
  >([]);
  const [updatePlayers, setUpdatePlayers] = useState(false);
  const [playerHasVoted, setPlayerHasVoted] = useState(false);

  useFocusEffect(
    React.useCallback(() => {
      let isActive = true;

      const getAllPlayers = async () => {
        try {
          const response = await axios.get(`${backendUrl}/players`);
          console.log("Response", response.data.players);
          if (isActive) {
            const filteredPlayers = response.data.players
              .filter((item: { is_alive: boolean }) => item.is_alive)
              .filter((item: { sid: string }) => item.sid !== player.sid);
            setPlayerSelection(filteredPlayers);
          }
        } catch (error) {
          console.error(error);
        }
      };

      getAllPlayers();

      return () => {
        isActive = false;
      };
    }, [player]),
  );

  const resetComponent = () => {
    setUpdatePlayers(true);
    setPlayerHasVoted(false);
    setPlayerSelection([]);
  };

  useEffect(() => {
    if (playerString) {
      setPlayer(JSON.parse(playerString));
      const newPlayer = JSON.parse(playerString);
      console.log("Player string", newPlayer);
    }
  }, [playerString]);

  //useEffect(() => {
  //  const getAllPlayers = async () => {
  //    try {
  //      const response = await axios.get(`${backendUrl}/players`);
  //      console.log("Response", response.data.players);
  //      const filteredPlayers = response.data.players
  //        .filter((item: { is_alive: boolean }) => item.is_alive)
  //        .filter((item: { sid: string }) => item.sid !== player.sid);
  //      setPlayerSelection(filteredPlayers);
  //      setUpdatePlayers(false);
  //    } catch (error) {
  //      console.error(error);
  //    }
  //  };
  //
  //  getAllPlayers();
  //  setIsVisible(true);
  //}, [updatePlayers, isVisible]);

  const handleVote = (sid: string) => {
    setPlayerHasVoted(true);
    resetComponent();
    socket.emit("vote_kill", { sid });
    router.push({
      pathname: "/(tabs)/GameInterface",
      params: { player: JSON.stringify(player) },
    });
  };

  const renderPlayer = ({ item }: { item: { name: string; sid: string } }) => (
    <View className="flex-row justify-between items-center p-2 bg-white my-1 rounded-lg">
      <Text className="text-lg">{item.name}</Text>
      <Button
        title="Vote"
        disabled={playerHasVoted}
        onPress={() => handleVote(item.sid)}
      />
    </View>
  );

  return (
    <SafeAreaView className="flex-1 bg-gray-900 p-4">
      <Text className="text-white text-center text-2xl mb-4">
        Choose a player to vote for killing:
      </Text>
      {playerSelection && (
        <FlatList
          data={playerSelection}
          renderItem={renderPlayer}
          keyExtractor={(item) => item.sid}
          className="text-white"
        />
      )}
    </SafeAreaView>
  );
};

export default DayVote;

================
File: app/(tabs)/Death.tsx
================
import React from "react";
import { SafeAreaView, Text, TouchableOpacity, View } from "react-native";
import { useRouter } from "expo-router";

const DeathScreen: React.FC = () => {
  return (
    <SafeAreaView className="flex-1 bg-gray-900 items-center justify-center">
      <View className="w-80 h-80 bg-gradient-to-br from-red-600 to-red-900 rounded-xl items-center justify-center p-6 shadow-xl border border-gray-200">
        <Text className="text-white text-3xl font-bold mb-4 text-center">
          Vous etes mort, pas le droit de parler !
        </Text>
      </View>
    </SafeAreaView>
  );
};

export default DeathScreen;

================
File: app/(tabs)/GameInterface.tsx
================
import { Text, View, TouchableOpacity, Button, Modal } from "react-native";
import { SafeAreaView } from "react-native-safe-area-context";
import { useLocalSearchParams, useRouter } from "expo-router";
import React, { useState, useEffect } from "react";
import { Player } from "../../types";
import { getRoleDescription } from "../../constants/roles";
import { socket } from "@/utils/sockets.js";
import Cupidon from "@/components/roles/Cupidon";
import Hunter from "@/components/roles/Hunter";
import LoveAlert from "./LoveAlert";
import WitchHeal from "./WitchHeal";
import WitchKill from "./WitchKill";
import * as Haptics from "expo-haptics";

const GameInterface: React.FC = () => {
  const router = useRouter();

  const [player, setPlayer] = useState<Player | null>(null);
  const [showDescription, setShowDescription] = useState(false);
  const [showCupidon, setShowCupidon] = useState(false);
  const [showHunter, setShowHunter] = useState(false);
  const [isInLove, setIsInLove] = useState(false);
  const [loverName, setLoverName] = useState("");
  const [showWitchHeal, setShowWitch] = useState(false);
  const [werewolfTarget, setWerewolfTarget] = useState("");
  const [showWitchKillModal, setShowWitchKillModal] = useState(false);
  const [showWitchKill, setShowWitchKill] = useState(false);

  const { player: playerString } = useLocalSearchParams() as { player: string };

  const handleCardPress = () => {
    setShowDescription(!showDescription);
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
  };

  useEffect(() => {
    if (playerString) {
      console.log("Player string is", playerString);
      const parsedPlayer: Player = JSON.parse(playerString);
      setPlayer(parsedPlayer);
    }
  }, []);

  useEffect(() => {
    console.log("Werewolf target is", werewolfTarget);
    if (werewolfTarget) {
      console.log("Setting show werewolf to true");
      setShowWitch(true);
    }
  }, [werewolfTarget]);

  useEffect(() => {
    const handleCupidonChoice = () => {
      setShowCupidon(true);
    };

    const handleIsInLove = (data: { lover: string }) => {
      setIsInLove(true);
      setLoverName(data.lover);
      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium)
        .then(() => console.log("Haptic feedback triggered"))
        .catch((error) =>
          console.error("Error triggering haptic feedback", error),
        );
    };

    const handleDeath = () => {
      cleanup();
      router.push("/(tabs)/Death");
    };

    const handleSeerChoice = () => {
      if (player) {
        router.push({
          pathname: "/(tabs)/Seer",
          params: { player: JSON.stringify(player) },
        });
      }
    };

    const handleWitchHeel = (data: { victim: string }) => {
      const victim = data.victim;
      setWerewolfTarget(victim);
    };

    const handleDayVote = () => {
      router.push({
        pathname: "/(tabs)/DayVote",
        params: { player: JSON.stringify(player) },
      });
    };

    const handleWerewolfWakeUp = () => {
      if (player) {
        try {
          router.push({
            pathname: "/(tabs)/Werewolf",
            params: { player: JSON.stringify(player) },
          });
          console.log("Router push completed");
        } catch (error) {
          console.error("Navigation error:", error);
        }
      }
    };
    const handleWitchKill = () => {
      setShowWitchKillModal(true);
    };

    const cleanup = () => {
      socket.off("cupidon_choice", handleCupidonChoice);
      socket.off("alert_lovers", handleIsInLove);
      socket.off("witch_heel", handleWitchHeel);
      socket.off("alert_dead", handleDeath);
      socket.off("werewolf_wake_up", handleWerewolfWakeUp);
      socket.off("day_vote", handleDayVote);
      socket.off("witch_kill", handleWitchKill);
      socket.off("seer_choice", handleSeerChoice);
    };

    socket.once("cupidon_choice", handleCupidonChoice);
    socket.once("alert_lovers", handleIsInLove);
    socket.on("witch_heal", handleWitchHeel);
    socket.on("alert_dead", handleDeath);
    socket.on("witch_kill", handleWitchKill);
    socket.on("werewolf_wake_up", handleWerewolfWakeUp);
    socket.on("day_vote", handleDayVote);
    socket.on("seer_choice", handleSeerChoice);

    return () => {
      cleanup();
    };
  }, [player]);

  useEffect(() => {
    if (player && showWitchKill) {
      try {
        router.push({
          pathname: "/(tabs)/WitchKill",
          params: { player: JSON.stringify(player) },
        });
      } catch (error) {
        console.error("Navigation error:", error);
      }
    }
  }, [showWitchKill]);

  const handleShowWitchKillModal = (choice: string) => {
    if (choice === "yes") {
      setShowWitchKill(true);
      setShowWitchKillModal(false);
    } else {
      setShowWitchKillModal(false);
      socket.emit("witch_no_kill");
    }
  };

  return (
    <SafeAreaView className="flex-1 bg-gray-900 items-center justify-center">
      <Text className="text-white text-2xl mb-5">Game Interface</Text>
      <Text className="text-white text-lg mb-5">Player: {player?.name}</Text>

      <TouchableOpacity
        onPress={handleCardPress}
        className="active:scale-95 transform transition-all"
      >
        <View className="w-72 h-96 bg-gradient-to-br from-white to-gray-100 rounded-xl items-center justify-between p-6 shadow-xl border border-gray-200">
          <View className="w-full flex items-center">
            {!showDescription ? (
              <>
                <View className="w-16 h-16 bg-gray-900 rounded-full mb-4 items-center justify-center">
                  <Text className="text-white text-2xl">?</Text>
                </View>
                <Text className="text-gray-800 text-lg font-medium text-center">
                  Appuyez sur la carte pour révéler votre rôle
                </Text>
              </>
            ) : (
              <>
                <Text className="text-white text-2xl font-bold mb-4">
                  {player?.role?.toUpperCase()}
                </Text>
                <View className="border-t border-gray-200 w-full pt-4">
                  <Text className="text-gray-400 text-lg text-center leading-relaxed">
                    {player?.role ? getRoleDescription(player.role) : ""}
                  </Text>
                </View>
              </>
            )}
          </View>
        </View>

        {loverName && (
          <LoveAlert
            visible={isInLove}
            onClose={() => {
              setIsInLove(false);
              socket.emit("lover_alert_closed");
              socket.emit("lover_alert_closed"); // TODO: Remove this line this is for testing purposes since we only have one player
            }}
            loverName={loverName}
          />
        )}

        {player && (
          <>
            <Cupidon
              visible={showCupidon}
              onClose={() => setShowCupidon(false)}
              cupidonName={player.name}
            />
            <Hunter
              visible={showHunter}
              onClose={() => setShowHunter(false)}
              hunterName={player.name}
            />
            <WitchHeal
              visible={showWitchHeal}
              onClose={() => setShowWitch(false)}
              victim={werewolfTarget}
            />
          </>
        )}
        {showWitchKillModal && (
          <Modal
            visible={showWitchKillModal}
            animationType="slide"
            transparent={true}
            onRequestClose={() => setShowWitchKillModal(false)}
          >
            <View className="flex-1 justify-center items-center bg-gray-50/50 bg-opacity-50">
              <View className="bg-white p-6 rounded-lg shadow-lg w-80">
                <Text className="text-black text-xl mb-4">
                  Voulez-vous tuer quelqu'un?
                </Text>
                <View className="flex-row justify-between">
                  <TouchableOpacity
                    onPress={() => handleShowWitchKillModal("yes")}
                    className="bg-red-500 p-3 rounded-lg"
                  >
                    <Text className="text-white">Oui</Text>
                  </TouchableOpacity>
                  <TouchableOpacity
                    onPress={() => handleShowWitchKillModal("no")}
                    className="bg-green-500 p-3 rounded-lg"
                  >
                    <Text className="text-white">Non</Text>
                  </TouchableOpacity>
                </View>
              </View>
            </View>
          </Modal>
        )}
      </TouchableOpacity>
    </SafeAreaView>
  );
};

export default GameInterface;

================
File: app/(tabs)/index.tsx
================
import axios from "axios";
import { useState, useEffect } from "react";
import { Link, useRouter } from "expo-router";
import { SafeAreaView } from "react-native-safe-area-context";
import { View, Text, TextInput, Button, ImageBackground } from "react-native";
import { Player } from "../../types";
import { socket } from "@/utils/sockets.js";

import "../../global.css";

export default function HomeScreen() {
  const router = useRouter();
  const [name, setName] = useState("");

  const handleJoinGame = () => {
    socket.emit("add_player", { name });
    socket.on("player_data", (playerData) => {
      router.push({
        pathname: "/(tabs)/waiting-room",
        params: { player: JSON.stringify(playerData) },
      });
    });
  };

  return (
    <ImageBackground
      source={require("../../assets/images/background-app-3.jpeg")}
      className="flex-1"
    >
      <SafeAreaView className="flex-1 justify-end pb-24 items-center">
        <View className="w-4/5 items-center bg-opacity-50 p-5 rounded-lg">
          <Text className="text-2xl text-white mb-5">Werewolf Game</Text>
          <TextInput
            className="w-full p-2 border border-gray-400 rounded mb-5 bg-white"
            placeholder="Enter your name"
            value={name}
            onChangeText={setName}
          />
          <Button title="Join Game" onPress={handleJoinGame} />
        </View>
      </SafeAreaView>
    </ImageBackground>
  );
}

================
File: app/(tabs)/LoveAlert.tsx
================
import React from "react";
import { SafeAreaView, Text, Button, Modal, View } from "react-native";
import { useState, useEffect } from "react";
import { socket } from "@/utils/sockets.js";
import { DotLottieReact } from "@lottiefiles/dotlottie-react";

const LoveAlert = ({
  visible,
  onClose,
  loverName,
}: {
  visible: boolean;
  onClose: () => void;
  loverName: string;
}) => {
  const [isDisabled, setIsDisabled] = useState(true);

  useEffect(() => {
    socket.on("lover_can_close", () => {
      setIsDisabled(false);
    });
  }, []);
  return (
    <Modal visible={visible} animationType="slide" onRequestClose={onClose}>
      <SafeAreaView className="flex-1 bg-gray-900 items-center justify-center">
        <View className="w-72 h-96 bg-white rounded-lg items-center justify-center shadow-lg p-5">
          <Text className="text-black text-2xl mb-5">Love Alert</Text>
          <Text className="text-black text-lg mb-2">
            Vous etes en couple avec {loverName}! import React from 'react';
            <DotLottieReact
              src="https://lottie.host/642926d8-410a-4448-a2ca-424ba17a7cec/nUqC3zTrJK.lottie"
              loop
              autoplay
            />
          </Text>
          <Button title="Close" onPress={onClose} disabled={isDisabled} />
        </View>
      </SafeAreaView>
    </Modal>
  );
};

export default LoveAlert;

================
File: app/(tabs)/Seer.tsx
================
import React, { useEffect, useState } from "react";
import { View, Text, Dimensions, TouchableOpacity } from "react-native";
import { Gesture, GestureDetector } from "react-native-gesture-handler";
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withTiming,
  withSpring,
  withDecay,
  useDerivedValue,
  runOnJS,
  interpolate,
  Extrapolation,
} from "react-native-reanimated";
import { useRouter } from "expo-router";
import { socket } from "@/utils/sockets";
import axios from "axios";
import { backendUrl } from "@/utils/config";
import { Player } from "@/types";

const { width, height } = Dimensions.get("window");
const TWO_PI = 2 * Math.PI;

const minSize = 120;
const cardSize = {
  width: minSize,
  height: minSize * 1.67,
  borderRadius: 12,
};

const cardSizeVisiblePercentage = 0.9;
const cardSizeOnCircle = cardSizeVisiblePercentage * cardSize.width;
const circleRadius = Math.max(((cardSizeOnCircle * 8) / TWO_PI) * 1, width / 1);
const circleCircumference = TWO_PI * circleRadius;
const changeFactor = circleCircumference / width;
const theta = (TWO_PI / 8) * 0.3;

interface PlayerCardProps {
  player: Player;
  cardIndex: number;
  index: any;
  activeIndex: any;
  mounted: any;
}

const PlayerCard: React.FC<PlayerCardProps> = ({
  player,
  cardIndex,
  index,
  activeIndex,
  mounted,
}) => {
  const cardStyle = useAnimatedStyle(() => {
    const isActive = activeIndex.value === cardIndex;
    const offset = isActive ? -cardSize.height / 2 : 0;

    return {
      transform: [
        {
          rotate: `${interpolate(
            mounted.value,
            [0, 1],
            [0, theta * cardIndex],
          )}rad`,
        },
        { translateY: withSpring(offset) },
      ],
    };
  });

  return (
    <Animated.View
      style={[
        {
          width: cardSize.width,
          height: circleRadius * 2,
          position: "absolute",
          shadowColor: "#000",
          shadowOffset: { width: 0, height: 1 },
          shadowOpacity: 0.3,
          shadowRadius: 4,
          elevation: 4,
        },
        cardStyle,
      ]}
    >
      <View
        style={{
          width: cardSize.width,
          height: cardSize.height,
          borderRadius: cardSize.borderRadius,
          backgroundColor: "white",
          padding: 16,
          borderWidth: 4,
          borderColor: "white",
          shadowColor: "#000",
          shadowOffset: { width: 0, height: 2 },
          shadowOpacity: 0.25,
          shadowRadius: 3.84,
          elevation: 5,
        }}
      >
        <Text style={{ fontSize: 18, fontWeight: "700", textAlign: "center" }}>
          {player.name}
        </Text>
      </View>
    </Animated.View>
  );
};

interface SeerWheelProps {
  players: Player[];
  onPlayerSelect: (player: Player) => void;
}

const SeerWheel: React.FC<SeerWheelProps> = ({ players, onPlayerSelect }) => {
  const distance = useSharedValue(0);
  const mounted = useSharedValue(0);
  const numberOfPlayers = players.length;

  useEffect(() => {
    mounted.value = withTiming(1, { duration: 500 });
  }, []);

  const angle = useDerivedValue(() => distance.value / circleCircumference);

  const interpolatedIndex = useDerivedValue(() => {
    const x = Math.abs((angle.value % TWO_PI) / theta);
    return angle.value < 0 ? x : numberOfPlayers - x;
  });

  const activeIndex = useDerivedValue(
    () => Math.round(interpolatedIndex.value) % numberOfPlayers,
  );

  const pan = Gesture.Pan()
    .onChange((ev) => {
      distance.value += ev.changeX * changeFactor;
    })
    .onFinalize((ev) => {
      distance.value = withDecay(
        {
          velocity: ev.velocityX,
          velocityFactor: changeFactor,
          deceleration: 0.998,
        },
        () => {
          const newAngle = -activeIndex.value * theta;
          distance.value = withSpring(newAngle * circleCircumference);
          runOnJS(onPlayerSelect)(players[activeIndex.value]);
        },
      );
    });

  const wheelStyle = useAnimatedStyle(() => ({
    transform: [{ rotate: `${angle.value}rad` }],
  }));

  return (
    <GestureDetector gesture={pan}>
      <Animated.View
        style={[
          {
            width: circleRadius * 2,
            height: circleRadius * 2,
            position: "absolute",
            justifyContent: "center",
            alignItems: "center",
            alignSelf: "center",
            top: height - cardSize.height * 2,
          },
          wheelStyle,
        ]}
      >
        {players.map((player, index) => (
          <PlayerCard
            key={player.sid}
            player={player}
            cardIndex={index}
            index={interpolatedIndex}
            activeIndex={activeIndex}
            mounted={mounted}
          />
        ))}
      </Animated.View>
    </GestureDetector>
  );
};

export default function SeerView() {
  const router = useRouter();
  const [players, setPlayers] = useState<Player[]>([]);
  const [selectedPlayer, setSelectedPlayer] = useState<Player | null>(null);
  const [playerRole, setPlayerRole] = useState<string | null>(null);
  const roleRevealAnimation = useSharedValue(0);

  useEffect(() => {
    const fetchPlayers = async () => {
      try {
        const response = await axios.get(`${backendUrl}/players`);
        const allPlayers = response.data.players;
        setPlayers(allPlayers);
      } catch (error) {
        console.error("Erreur lors de la récupération des joueurs :", error);
      }
    };
    fetchPlayers();

    socket.on("role_reveal", (data) => {
      console.log("Rôle révélé :", data);
      setPlayerRole(data.role);
      roleRevealAnimation.value = withTiming(1, { duration: 500 });
      setTimeout(() => {
        roleRevealAnimation.value = withTiming(0, { duration: 500 });
        setPlayerRole(null);
        router.push("/(tabs)/GameInterface");
      }, 5000);
    });

    return () => {
      socket.off("role_reveal");
    };
  }, []);

  const handlePlayerSelect = (player: Player) => {
    setSelectedPlayer(player);
  };

  const handleConfirmSelection = () => {
    if (selectedPlayer) {
      socket.emit("seer_check", { sid: selectedPlayer.sid });
    }
  };

  const roleRevealStyle = useAnimatedStyle(() => ({
    transform: [
      {
        scale: interpolate(
          roleRevealAnimation.value,
          [0, 0.8, 1],
          [0.5, 1.2, 1],
          Extrapolation.CLAMP,
        ),
      },
      {
        translateY: interpolate(
          roleRevealAnimation.value,
          [0, 1],
          [50, 0],
          Extrapolation.CLAMP,
        ),
      },
    ],
    opacity: interpolate(
      roleRevealAnimation.value,
      [0, 0.5, 1],
      [0, 1, 1],
      Extrapolation.CLAMP,
    ),
  }));

  const glowStyle = useAnimatedStyle(() => ({
    shadowColor: "gold",
    shadowOpacity: interpolate(
      roleRevealAnimation.value,
      [0, 0.5, 1],
      [0, 0.8, 0.5],
      Extrapolation.CLAMP,
    ),
    shadowRadius: interpolate(
      roleRevealAnimation.value,
      [0, 0.5, 1],
      [0, 20, 10],
      Extrapolation.CLAMP,
    ),
    shadowOffset: { width: 0, height: 0 },
  }));

  return (
    <View className="flex-1 bg-gray-900">
      <View className="flex-1 items-center justify-center">
        <SeerWheel players={players} onPlayerSelect={handlePlayerSelect} />

        {selectedPlayer && (
          <View className="absolute top-20 items-center">
            <Text className="text-white text-xl mb-4">
              Sélectionné : {selectedPlayer.name}
            </Text>
            <TouchableOpacity
              onPress={handleConfirmSelection}
              className="bg-blue-500 px-6 py-3 rounded-lg"
              disabled={roleRevealAnimation.value === 1}
            >
              <Text className="text-white font-bold">Révéler le rôle</Text>
            </TouchableOpacity>
          </View>
        )}

        {playerRole && (
          <Animated.View
            style={[
              {
                position: "absolute",
                alignItems: "center",
                alignSelf: "center",
                top: height / 2 - 150,
                backgroundColor: "white",
                padding: 20,
                borderRadius: 12,
                elevation: 10,
                zIndex: 10,
                height: height / 4,
              },
              roleRevealStyle,
              glowStyle,
            ]}
          >
            <Text
              style={{
                fontSize: 18,
                fontWeight: "700",
                textAlign: "center",
                color: "gold",
              }}
            >
              Rôle Révélé
            </Text>
            <Text
              style={{
                fontSize: 32,
                fontWeight: "bold",
                textAlign: "left",
                color: "#333",
                paddingTop: 30,
              }}
            >
              {playerRole}
            </Text>
          </Animated.View>
        )}
      </View>
    </View>
  );
}

================
File: app/(tabs)/test-page.tsx
================
import React from "react";
import { View } from "react-native";
import LottieView from "lottie-react-native";
import { StyleSheet } from "react-native";

const TestSocketPage = () => {
  return (
    <View style={styles.container}>
      <LottieView
        source={require("./../../assets/Animation.lottie")}
        style={styles.animation}
        autoPlay
        loop
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
  },
  animation: {
    width: "100%",
    height: "100%",
  },
});

export default TestSocketPage;

================
File: app/(tabs)/TestingInterface.tsx
================
import React, { useState, useEffect } from "react";
import {
  View,
  Text,
  TouchableOpacity,
  ScrollView,
  TextInput,
  Button,
} from "react-native";
import { socket } from "@/utils/sockets";
import { Picker } from "@react-native-picker/picker";
import axios from "axios";
import { backendUrl } from "@/utils/config";

interface Player {
  name: string;
  sid: string;
  role?: string;
  is_alive: boolean;
}

interface MockPlayer extends Player {
  isMock: boolean;
}

interface PendingAction {
  type: string;
  data?: any;
  options?: any;
}

const MockGameManager = () => {
  const [mockPlayers, setMockPlayers] = useState<MockPlayer[]>([]);
  const [numOfMockPlayers, setNumOfMockPlayers] = useState<number>(0);
  const [pendingActions, setPendingActions] = useState<{
    [key: string]: PendingAction;
  }>({});
  const [werewolfVotes, setWerewolfVotes] = useState<{ [key: string]: string }>(
    {},
  );

  // Fetch players
  const fetchPlayers = async () => {
    try {
      const response = await axios.get(`${backendUrl}/players`);
      const allPlayers = response.data.players;
      setMockPlayers(allPlayers);
    } catch (error) {
      console.error("Error fetching players:", error);
    }
  };

  useEffect(() => {
    fetchPlayers();
  }, []);

  useEffect(() => {
    // Role assignment
    socket.on("role_assigned", (data: { role: string; sid: string }) => {
      setMockPlayers((prev) =>
        prev.map((p) => (p.sid === data.sid ? { ...p, role: data.role } : p)),
      );
    });

    // Cupidon choice
    socket.on("cupidon_choice", (data: { message: string }) => {
      const cupid = mockPlayers.find((p) => p.role === "cupid");
      if (cupid) {
        setPendingActions((prev) => ({
          ...prev,
          [cupid.sid]: { type: "cupidon", data },
        }));
      }
    });

    // Werewolf phase
    socket.on(
      "werewolf_wake_up",
      (data: { message: string; other_werewolves: string[] }) => {
        const werewolves = mockPlayers.filter((p) => p.role === "werewolf");
        werewolves.forEach((werewolf) => {
          setPendingActions((prev) => ({
            ...prev,
            [werewolf.sid]: { type: "werewolf", data },
          }));
        });
      },
    );

    console.log(
      "Socket listeners count:",
      socket.listeners("alert_lovers").length,
    );
    socket.on("lover_can_close", handleIsInLove);

    // New werewolf vote count
    socket.on(
      "new_selection_count",
      (data: { werewolf: string; name: string; vote: string }) => {
        setWerewolfVotes((prev) => ({
          ...prev,
          [data.werewolf]: data.vote,
        }));
      },
    );

    // Witch actions
    socket.on("witch_heal", (data: { message: string; victim: string }) => {
      const witch = mockPlayers.find((p) => p.role === "witch");
      if (witch) {
        setPendingActions((prev) => ({
          ...prev,
          [witch.sid]: { type: "witch_heal", data },
        }));
      }
    });

    socket.on("witch_kill", (data: { message: string }) => {
      const witch = mockPlayers.find((p) => p.role === "witch");
      if (witch) {
        setPendingActions((prev) => ({
          ...prev,
          [witch.sid]: { type: "witch_kill", data },
        }));
      }
    });

    // Day vote
    socket.on("day_vote", () => {
      const alivePlayers = mockPlayers.filter((p) => p.is_alive);
      console.log("Alive players:", alivePlayers);
      alivePlayers.forEach((player) => {
        setPendingActions((prev) => ({
          ...prev,
          [player.sid]: { type: "day_vote" },
        }));
      });
    });

    // Player death
    socket.on("alert_dead", () => {
      const playerSid = socket.id;
      setMockPlayers((prev) =>
        prev.map((p) => (p.sid === playerSid ? { ...p, is_alive: false } : p)),
      );
    });

    return () => {
      socket.off("role_assigned");
      socket.off("cupidon_choice");
      socket.off("werewolf_wake_up");
      socket.off("new_selection_count");
      socket.off("witch_heal");
      socket.off("witch_kill");
      socket.off("day_vote");
      socket.off("alert_dead");
      socket.off("lover_can_close", handleIsInLove);
    };
  }, [mockPlayers]);

  useEffect(() => {
    fetchPlayers();
  }, [pendingActions]);

  const handleIsInLove = (data: { lover: string }) => {
    console.log("Lover alert received", data);
    socket.emit("lover_alert_closed");
  };

  const emitAlertLoversClosed = () => {
    socket.emit("alert_lovers_closed");
    socket.emit("alert_lovers_closed");
  };

  // Initialize mock players
  const addMockPlayers = (count: number) => {
    const newPlayers: MockPlayer[] = [];

    for (let i = 0; i < count; i++) {
      const mockPlayer: MockPlayer = {
        name: `TestPlayer${mockPlayers.length + i + 1}`,
        sid: `mock_${Date.now()}_${i}`,
        is_alive: true,
        isMock: true,
      };
      newPlayers.push(mockPlayer);
    }

    socket.emit("add_mock_players", {
      players: newPlayers,
      controllerSid: socket.id,
    });

    setMockPlayers((prev) => [...prev, ...newPlayers]);
  };

  const handleAction = (playerId: string, actionType: string, data: any) => {
    switch (actionType) {
      case "cupidon":
        socket.emit("cupidon_selection_complete", data);
        break;
      case "werewolf":
        socket.emit("werewolf_kill", data);
        break;
      case "witch_heal":
        socket.emit("witch_heal_victim");
        break;
      case "witch_kill":
        socket.emit("witch_kill_victim", { sid: data });
        break;
      case "day_vote":
        socket.emit("vote_kill", { sid: data });
        break;
    }

    setPendingActions((prev) => {
      const newActions = { ...prev };
      delete newActions[playerId];
      return newActions;
    });
  };

  const renderActionControls = (player: MockPlayer, action: PendingAction) => {
    switch (action.type) {
      case "day_vote":
        return (
          <View className="mt-2">
            {mockPlayers
              .filter((p) => p.is_alive && p.sid !== player.sid)
              .map((target) => (
                <TouchableOpacity
                  key={target.sid}
                  onPress={() =>
                    handleAction(player.sid, "day_vote", target.sid)
                  }
                  className="bg-blue-500 p-2 rounded mt-1"
                >
                  <Text className="text-white">Vote {target.name}</Text>
                </TouchableOpacity>
              ))}
          </View>
        );

      case "werewolf":
        return (
          <View className="mt-2">
            {mockPlayers
              .filter((p) => p.is_alive && p.role !== "werewolf")
              .map((target) => (
                <TouchableOpacity
                  key={target.sid}
                  onPress={() =>
                    handleAction(player.sid, "werewolf", target.sid)
                  }
                  className="bg-blue-500 p-2 rounded mt-1"
                >
                  <Text className="text-white">Kill {target.name}</Text>
                </TouchableOpacity>
              ))}
          </View>
        );

      // Add more action type renders as needed

      default:
        return null;
    }
  };

  return (
    <ScrollView className="flex-1 bg-gray-100">
      <View className="p-4">
        <View className="mb-6">
          <Text className="text-xl font-bold mb-4">Mock Game Controls</Text>
          <TextInput
            value={numOfMockPlayers.toString()}
            className="border p-2 rounded w-20 mb-6"
            onChangeText={(text) => setNumOfMockPlayers(parseInt(text))}
          />
          <Picker
            className="border p-2 rounded w-20 mb-6"
            onValueChange={(value) => setNumOfMockPlayers(parseInt(value))}
            selectedValue={numOfMockPlayers.toString()}
          >
            <Picker.Item label="1" value="1" />
            <Picker.Item label="2" value="2" />
            <Picker.Item label="3" value="3" />
            <Picker.Item label="4" value="4" />
            <Picker.Item label="5" value="5" />
            <Picker.Item label="6" value="6" />
            <Picker.Item label="7" value="7" />
            <Picker.Item label="8" value="8" />
            <Picker.Item label="9" value="9" />
            <Picker.Item label="10" value="10" />
          </Picker>

          <TouchableOpacity
            onPress={() => addMockPlayers(numOfMockPlayers)}
            className="bg-blue-500 p-4 rounded"
          >
            <Text className="text-white text-center">Add Mock Players</Text>
          </TouchableOpacity>
        </View>

        <View className="mb-6">
          <Text className="font-bold mb-2">
            Mock Players ({mockPlayers.length})
          </Text>
          {mockPlayers.map((player) => (
            <View key={player.sid} className="bg-white p-4 rounded mb-2">
              <Text style={{ color: !player.is_alive ? "red" : "black" }}>
                {player.name} - {player.role || "No role"}
                {!player.is_alive && " (Dead)"}
              </Text>

              {pendingActions[player.sid] && (
                <View className="mt-2 bg-yellow-100 p-2 rounded">
                  <Text>
                    Action Required: {pendingActions[player.sid].type}
                  </Text>
                  {renderActionControls(player, pendingActions[player.sid])}
                </View>
              )}
            </View>
          ))}
        </View>

        <Button
          title="Emit alert lovers closed"
          onPress={emitAlertLoversClosed}
        />
      </View>
    </ScrollView>
  );
};

export default MockGameManager;

================
File: app/(tabs)/waiting-room.tsx
================
import React, { useEffect, useState } from "react";
import { SafeAreaView } from "react-native-safe-area-context";
import { Text, View, Button } from "react-native";
import axios from "axios";
import { useRouter } from "expo-router";
import { socket } from "@/utils/sockets.js";
import { Player } from "../../types";
import { useLocalSearchParams } from "expo-router";
import { backendUrl } from "@/utils/config";
import { MotiView } from "moti";
import Svg, { Circle } from "react-native-svg";

type CustomCircleProps = {
  radius?: number;
  strokeWidth?: number;
  color?: string;
  delay?: number;
};

function CustomCircle({
  radius = 40,
  strokeWidth = 4,
  color = "#000",
  delay = 5,
}: CustomCircleProps) {
  const circumference = 2 * Math.PI * radius;
  const halfCircle = radius + strokeWidth;
  const wantedAngle = 60;
  const angleInRadians = (wantedAngle * Math.PI) / 180;
  const arcLength = radius * angleInRadians;
  const strokeDashoffset = circumference - arcLength;
  const initialAngle = (180 - wantedAngle) / 2 + wantedAngle;

  return (
    <MotiView
      style={{ width: radius * 2, height: radius * 2, position: "absolute" }}
      from={{ rotate: `-${initialAngle}deg` }}
      animate={{ rotate: `-${360 + initialAngle}deg` }}
      transition={{
        damping: 80,
        mass: 1,
        stiffness: 200,
        loop: true,
        delay,
      }}
    >
      <Svg
        width={halfCircle * 2}
        height={halfCircle * 2}
        viewBox={`0 0 ${halfCircle * 2} ${halfCircle * 2}`}
      >
        <Circle
          cx="50%"
          cy="50%"
          r={radius}
          fill="transparent"
          stroke={color}
          strokeWidth={strokeWidth}
          strokeLinecap="round"
          strokeDashoffset={strokeDashoffset}
          strokeDasharray={circumference}
        />
      </Svg>
    </MotiView>
  );
}

function LoadingCircles({
  size = 30,
  count = 3,
  frontColor = "#504774",
  backColor = "#EF7519",
  stagger = 100,
}) {
  return (
    <View>
      <View className="items-center justify-center">
        {[...Array(count).keys()].map((i) => {
          const strokeWidth = Math.floor(size / 3);
          const radius = i * strokeWidth * 2 + size;
          return (
            <CustomCircle
              key={`back-${i}`}
              radius={radius}
              delay={stagger + i * stagger}
              color={backColor}
              strokeWidth={strokeWidth}
            />
          );
        })}
      </View>
      <View className="items-center justify-center">
        {[...Array(count).keys()].map((i) => {
          const strokeWidth = Math.floor(size / 3);
          const radius = i * strokeWidth * 2 + size;
          return (
            <CustomCircle
              key={`front-${i}`}
              radius={radius}
              delay={i * stagger}
              color={frontColor}
              strokeWidth={strokeWidth}
            />
          );
        })}
      </View>
    </View>
  );
}

const WaitingRoom = () => {
  const { player: playerString } = useLocalSearchParams() as { player: string };
  const [player, setPlayer] = useState<Player>(JSON.parse(playerString));
  const [playerHasRole, setPlayerHasRole] = useState(false);
  const router = useRouter();
  const [players, setPlayers] = useState<Player[]>([]);
  const [startGame, setStartGame] = useState(false);
  const [updatePlayers, setUpdatePlayers] = useState(false);

  useEffect(() => {
    const getAllPlayers = async () => {
      try {
        const response = await axios.get(`${backendUrl}/players`);
        const playerData = response.data.players;
        setPlayers(playerData);
        setUpdatePlayers(false);
      } catch (error) {
        console.error(error);
      }
    };

    getAllPlayers();
  }, [updatePlayers]);

  useEffect(() => {
    socket.on("update_players_list", () => {
      setUpdatePlayers(true);
    });
  }, []);

  const assignRole = (data: { role: string }) => {
    const newPlayer = { ...player, role: data.role };
    setPlayer(newPlayer);
    setPlayerHasRole(true);
  };

  useEffect(() => {
    socket.on("role_assigned", (data) => {
      assignRole(data);
    });

    return () => {
      socket.off("assign_roles");
    };
  }, []);

  useEffect(() => {
    if (playerHasRole) {
      router.push({
        pathname: "/(tabs)/GameInterface",
        params: { player: JSON.stringify(player) },
      });
    }
  }, [playerHasRole]);

  return (
    <SafeAreaView className="flex-1 items-center justify-center">
      <View className="space-y-5 gap-36 pt-32">
        <LoadingCircles size={30} count={3} stagger={100} />
        <Text className="text-white">
          {players.length === 0
            ? "Vous etes seul dans la salle d'attente, attendez que d'autres joueurs vous rejoignent"
            : `${players.map((player) => player.name).join(", ")} attendent avec vous`}
        </Text>
      </View>
    </SafeAreaView>
  );
};

export default WaitingRoom;

================
File: app/(tabs)/Werewolf.tsx
================
import React, { useEffect, useState } from "react";
import { useRouter } from "expo-router";
import {
  SafeAreaView,
  Text,
  Button,
  FlatList,
  TouchableOpacity,
  View,
  Alert,
} from "react-native";
import axios from "axios";
import { socket } from "@/utils/sockets";
import { Player } from "../../types";
import { backendUrl } from "@/utils/config";
import { useLocalSearchParams } from "expo-router";

const Werewolf = () => {
  const router = useRouter();
  const { player: playerString } = useLocalSearchParams() as { player: string };
  const [player, setPlayer] = useState<Player>(JSON.parse(playerString));
  const [playerSelection, setPlayerSelection] = useState<
    { name: string; sid: string }[]
  >([]);
  const [selectedPlayer, setSelectedPlayer] = useState<string | null>(null);
  const [otherWerewolvesVote, setOtherWerewolvesVote] = useState<{
    [key: string]: string;
  }>({});
  const [totalWerewolves, setTotalWerewolves] = useState<number>(0);

  useEffect(() => {
    if (playerString) {
      setPlayer(JSON.parse(playerString));
    }
  }, [playerString]);

  useEffect(() => {
    const getAllPlayers = async () => {
      try {
        const response = await axios.get(`${backendUrl}/players`);
        const playerData = response.data.players;
        const werewolfCount = playerData.filter(
          (p: Player) => p.role === "werewolf",
        ).length;
        const werewolveSelection = playerData.filter(
          (p: Player) => p.role !== "werewolf",
        );
        setTotalWerewolves(werewolfCount);
        setPlayerSelection(werewolveSelection);
      } catch (error) {
        console.error(error);
      }
    };

    if (player) {
      getAllPlayers();
    }

    socket.on(
      "new_selection_count",
      (data: { werewolf: string; name: string; vote: string }) => {
        setOtherWerewolvesVote((prev) => {
          const newVotes = {
            ...prev,
            [data.werewolf]: data.vote,
          };

          return newVotes;
        });
      },
    );

    return () => {
      socket.off("new_selection_count");
    };
  }, [player, totalWerewolves]);

  useEffect(() => {
    const allVotesEqual = () => {
      const votes = Object.values(otherWerewolvesVote);
      if (votes.length === 0 || votes.length < totalWerewolves) return false;
      if (votes.every((vote) => vote === votes[0])) {
        socket.emit("werewolf_kill", votes[0]);
        console.log("All werewolves agree on killing", votes[0]);
        router.push({
          pathname: "/(tabs)/GameInterface",
          params: { player: JSON.stringify(player) },
        });
      }
    };

    allVotesEqual();
  }, [otherWerewolvesVote, playerSelection]);

  const togglePlayerSelection = (sid: string, name: string) => {
    setSelectedPlayer(sid);
    socket.emit("update_werewolf_selection_count", {
      werewolf: player.name,
      name: name,
      vote: sid,
    });
  };

  const handleWerewolfSelection = () => {
    const chosenPlayer = playerSelection.find((p) => p.sid === selectedPlayer);
    socket.emit("werewolf_kill", chosenPlayer);
    router.push({
      pathname: "/(tabs)/GameInterface",
      params: { player: JSON.stringify(player) },
    });
  };

  const getVoteCount = (sid: string): number => {
    return Object.values(otherWerewolvesVote).filter((vote) => vote === sid)
      .length;
  };

  const allWerewolvesAgree = () => {
    const votes = Object.values(otherWerewolvesVote);
    return votes.length > 0 && votes.every((vote) => vote === selectedPlayer);
  };

  const renderPlayer = ({ item }: { item: { name: string; sid: string } }) => {
    const voteCount = getVoteCount(item.sid);

    return (
      <TouchableOpacity
        onPress={() => togglePlayerSelection(item.sid, item.name)}
        style={{
          padding: 10,
          backgroundColor: selectedPlayer === item.sid ? "lightblue" : "white",
          marginVertical: 5,
          borderRadius: 8,
        }}
      >
        <View
          style={{
            flexDirection: "row",
            justifyContent: "space-between",
            alignItems: "center",
          }}
        >
          <Text style={{ fontSize: 16 }}>{item.name}</Text>
          <View
            style={{
              backgroundColor: "#e0e0e0",
              borderRadius: 12,
              padding: 4,
              minWidth: 24,
              alignItems: "center",
            }}
          >
            <Text style={{ fontSize: 14 }}>
              {voteCount}/{totalWerewolves}
            </Text>
          </View>
        </View>
      </TouchableOpacity>
    );
  };

  return (
    <SafeAreaView className="flex-1 bg-gray-900 h-full w-full">
      <Text className="text-white justify-center text-center text-xl mb-4">
        Choisissez un joueur à tuer:
      </Text>
      {playerSelection && (
        <FlatList
          data={playerSelection}
          renderItem={renderPlayer}
          keyExtractor={(item) => item.sid}
          className="text-white"
        />
      )}
      <Button
        title="Confirm Selection"
        onPress={handleWerewolfSelection}
        disabled={!allWerewolvesAgree()}
      />
    </SafeAreaView>
  );
};

export default Werewolf;

================
File: app/(tabs)/WitchHeal.tsx
================
import React from "react";
import { SafeAreaView, Text, Button, Modal, View } from "react-native";
import { useState, useEffect } from "react";
import { socket } from "@/utils/sockets.js";

const WitchHeal = ({
  visible,
  victim,
  onClose,
}: {
  visible: boolean;
  victim: string;
  onClose: () => void;
}) => {
  const handleChoice = (choice: string) => {
    choice === "yes"
      ? socket.emit("witch_heal_victim")
      : socket.emit("witch_no_heal");
    onClose();
  };

  return (
    <Modal visible={visible} animationType="slide">
      <SafeAreaView className="flex-1 bg-gray-900 items-center justify-center">
        <View className="w-80 h-96 bg-white rounded-lg items-center justify-center shadow-lg p-5">
          <Text className="text-black text-2xl mb-5">Guérison</Text>
          <Text className="text-black text-lg mb-2">
            Les loup-garous ont tué {victim}! Voulez-vous utiliser votre pouvoir
            de guérison?
          </Text>
          <View className="flex flex-row justify-between w-full">
            <Button title="Oui" onPress={() => handleChoice("yes")} />
            <Button title="Non" onPress={() => handleChoice("no")} />
          </View>
        </View>
      </SafeAreaView>
    </Modal>
  );
};

export default WitchHeal;

================
File: app/(tabs)/WitchKill.tsx
================
import React, { useEffect, useState } from "react";
import { useRouter } from "expo-router";
import {
  SafeAreaView,
  Text,
  Button,
  FlatList,
  TouchableOpacity,
  View,
  Alert,
} from "react-native";
import axios from "axios";
import { socket } from "@/utils/sockets";
import { Player } from "../../types";
import { backendUrl } from "@/utils/config";
import { useLocalSearchParams } from "expo-router";

const WitchKill = () => {
  const router = useRouter();
  const { player: playerString } = useLocalSearchParams() as { player: string };
  const [player, setPlayer] = useState<Player>(JSON.parse(playerString));
  const [playerSelection, setPlayerSelection] = useState<
    { name: string; sid: string }[]
  >([]);

  useEffect(() => {
    if (playerString) {
      setPlayer(JSON.parse(playerString));
    }
  }, [playerString]);

  useEffect(() => {
    const getAllPlayers = async () => {
      try {
        const response = await axios.get(`${backendUrl}/players`);
        const playerData = response.data.players;
        const filteredPlayers = playerData.filter(
          (p: Player) => p.role !== "witch",
        );
        setPlayerSelection(filteredPlayers);
      } catch (error) {
        console.error(error);
      }
    };

    if (player) {
      getAllPlayers();
    }
  }, [player]);

  const handleWitchKill = (sid: string, name: string) => {
    socket.emit("witch_kill_victim", { sid, name });
    router.push({
      pathname: "/(tabs)/GameInterface",
      params: { player: JSON.stringify(player) },
    });
  };

  const handleNoKill = () => {
    router.push({
      pathname: "/(tabs)/GameInterface",
      params: { player: JSON.stringify(player) },
    });
  };

  const renderPlayer = ({ item }: { item: { name: string; sid: string } }) => (
    <View className="flex-row justify-between items-center p-2 bg-white my-1 rounded-lg">
      <Text className="text-lg">{item.name}</Text>
      <Button
        title="Kill"
        onPress={() => handleWitchKill(item.sid, item.name)}
      />
    </View>
  );

  return (
    <SafeAreaView className="flex-1 bg-gray-900 p-4">
      <Text className="text-white text-center text-2xl mb-4">
        Choose a player to kill:
      </Text>
      {playerSelection && (
        <FlatList
          data={playerSelection}
          renderItem={renderPlayer}
          keyExtractor={(item) => item.sid}
          className="text-white"
        />
      )}
    </SafeAreaView>
  );
};

export default WitchKill;

================
File: app/_layout.tsx
================
import {
  DarkTheme,
  DefaultTheme,
  ThemeProvider,
} from "@react-navigation/native";
import { GestureHandlerRootView } from "react-native-gesture-handler";
import { useFonts } from "expo-font";
import { Stack } from "expo-router";
import * as SplashScreen from "expo-splash-screen";
import { StatusBar } from "expo-status-bar";
import { useEffect } from "react";

import { useColorScheme } from "@/hooks/useColorScheme";

// Prevent the splash screen from auto-hiding before asset loading is complete.
SplashScreen.preventAutoHideAsync();

export default function RootLayout() {
  const colorScheme = useColorScheme();
  const [loaded] = useFonts({
    SpaceMono: require("../assets/fonts/SpaceMono-Regular.ttf"),
  });

  useEffect(() => {
    if (loaded) {
      SplashScreen.hideAsync();
    }
  }, [loaded]);

  if (!loaded) {
    return null;
  }

  return (
    <GestureHandlerRootView style={{ flex: 1 }}>
      <ThemeProvider value={colorScheme === "dark" ? DarkTheme : DefaultTheme}>
        <Stack>
          <Stack.Screen name="(tabs)" options={{ headerShown: false }} />
          <Stack.Screen name="+not-found" />
        </Stack>
      </ThemeProvider>
    </GestureHandlerRootView>
  );
}

================
File: app/+not-found.tsx
================
import { Link, Stack } from 'expo-router';
import { StyleSheet } from 'react-native';

import { ThemedText } from '@/components/ThemedText';
import { ThemedView } from '@/components/ThemedView';

export default function NotFoundScreen() {
  return (
    <>
      <Stack.Screen options={{ title: 'Oops!' }} />
      <ThemedView style={styles.container}>
        <ThemedText type="title">This screen doesn't exist.</ThemedText>
        <Link href="/" style={styles.link}>
          <ThemedText type="link">Go to home screen!</ThemedText>
        </Link>
      </ThemedView>
    </>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    padding: 20,
  },
  link: {
    marginTop: 15,
    paddingVertical: 15,
  },
});

================
File: components/__tests__/__snapshots__/ThemedText-test.tsx.snap
================
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`renders correctly 1`] = `
<Text
  style={
    [
      {
        "color": "#11181C",
      },
      {
        "fontSize": 16,
        "lineHeight": 24,
      },
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
    ]
  }
>
  Snapshot test!
</Text>
`;

================
File: components/__tests__/ThemedText-test.tsx
================
import * as React from 'react';
import renderer from 'react-test-renderer';

import { ThemedText } from '../ThemedText';

it(`renders correctly`, () => {
  const tree = renderer.create(<ThemedText>Snapshot test!</ThemedText>).toJSON();

  expect(tree).toMatchSnapshot();
});

================
File: components/roles/Cupidon.tsx
================
import React, { useEffect, useState } from "react";
import { useRouter } from "expo-router";
import {
  SafeAreaView,
  Text,
  Button,
  FlatList,
  TouchableOpacity,
  Modal,
  View,
} from "react-native";
import axios from "axios";
import { socket } from "../../utils/sockets";
import { Player } from "../../types";
import { backendUrl } from "@/utils/config";

const Cupidon = ({
  visible,
  onClose,
  cupidonName,
}: {
  visible: boolean;
  onClose: () => void;
  cupidonName: string;
}) => {
  const router = useRouter();

  const [players, setPlayers] = useState<{ name: string; sid: string }[]>([]);
  const [selectedPlayers, setSelectedPlayers] = useState<string[]>([]);

  useEffect(() => {
    const fetchPlayers = async () => {
      try {
        const response = await axios.get(`${backendUrl}/players`);
        const allPlayers = response.data.players;
        setPlayers(
          allPlayers.filter((player: Player) => player.name !== cupidonName),
        );
      } catch (error) {
        console.error("Error fetching players:", error);
      }
    };

    fetchPlayers();
  }, []);

  const togglePlayerSelection = (sid: string) => {
    setSelectedPlayers((prevSelected) => {
      if (prevSelected.includes(sid)) {
        return prevSelected.filter((id) => id !== sid);
      } else if (prevSelected.length < 2) {
        return [...prevSelected, sid];
      } else {
        return prevSelected;
      }
    });
  };

  const handleCupidonSelection = (selectedPlayers: string[]) => {
    const chosenPlayers = players.filter((player) =>
      selectedPlayers.includes(player.sid),
    );
    socket.emit("cupidon_selection_complete", chosenPlayers);
    onClose();
    router.push("/(tabs)/GameInterface");
  };

  const renderPlayer = ({ item }: { item: { name: string; sid: string } }) => {
    return (
      <TouchableOpacity
        onPress={() => togglePlayerSelection(item.sid)}
        style={{
          padding: 10,
          backgroundColor: selectedPlayers.includes(item.sid)
            ? "lightblue"
            : "white",
          marginVertical: 5,
        }}
      >
        <Text>{item.name}</Text>
      </TouchableOpacity>
    );
  };

  return (
    <Modal visible={visible} animationType="slide" onRequestClose={onClose}>
      <SafeAreaView>
        <Text className="text-white justify-center text-center">
          Choose two players:
        </Text>

        <FlatList
          data={players}
          renderItem={renderPlayer}
          keyExtractor={(item) => item.sid}
        />
        <Button
          title="Confirm Selection"
          onPress={() => handleCupidonSelection(selectedPlayers)}
          disabled={selectedPlayers.length !== 2}
        />
      </SafeAreaView>
    </Modal>
  );
};

export default Cupidon;

================
File: components/roles/Hunter.tsx
================
import React, { useEffect, useState } from "react";
import { useRouter } from "expo-router";
import {
  SafeAreaView,
  Text,
  Button,
  FlatList,
  TouchableOpacity,
  Modal,
  View,
} from "react-native";
import axios from "axios";
import { socket } from "../../utils/sockets";
import { Player } from "../../types";
import { backendUrl } from "@/utils/config";

const Hunter = ({
  visible,
  onClose,
  hunterName,
}: {
  visible: boolean;
  onClose: () => void;
  hunterName: string;
}) => {
  const router = useRouter();
  const [players, setPlayers] = useState<{ name: string; sid: string }[]>([]);
  const [selectedPlayer, setSelectedPlayer] = useState<string | null>(null);

  useEffect(() => {
    const fetchPlayers = async () => {
      try {
        const response = await axios.get(`${backendUrl}/players`);
        const allPlayers = response.data.players;
        setPlayers(
          allPlayers.filter((player: Player) => player.name !== hunterName),
        );
      } catch (error) {
        console.error("Error fetching players:", error);
      }
    };
    fetchPlayers();
  }, []);

  const togglePlayerSelection = (sid: string) => {
    setSelectedPlayer(selectedPlayer === sid ? null : sid);
  };

  const handleHunterSelection = (selectedPlayer: string) => {
    const chosenPlayer = players.find(
      (player) => player.sid === selectedPlayer,
    );
    socket.emit("hunter_selection", chosenPlayer);
    onClose();
    router.push("/(tabs)/GameInterface");
  };

  const renderPlayer = ({ item }: { item: { name: string; sid: string } }) => {
    return (
      <TouchableOpacity
        onPress={() => togglePlayerSelection(item.sid)}
        style={{
          padding: 10,
          backgroundColor: selectedPlayer === item.sid ? "lightblue" : "white",
          marginVertical: 5,
        }}
      >
        <Text>{item.name}</Text>
      </TouchableOpacity>
    );
  };

  return (
    <Modal visible={visible} animationType="slide" onRequestClose={onClose}>
      <SafeAreaView>
        <Text className="text-white justify-center text-center">
          Choose a player to take down with you:
        </Text>
        <FlatList
          data={players}
          renderItem={renderPlayer}
          keyExtractor={(item) => item.sid}
        />
        <Button
          title="Confirm Selection"
          onPress={() =>
            selectedPlayer && handleHunterSelection(selectedPlayer)
          }
          disabled={!selectedPlayer}
        />
      </SafeAreaView>
    </Modal>
  );
};

export default Hunter;

================
File: components/ui/IconSymbol.ios.tsx
================
import { SymbolView, SymbolViewProps, SymbolWeight } from 'expo-symbols';
import { StyleProp, ViewStyle } from 'react-native';

export function IconSymbol({
  name,
  size = 24,
  color,
  style,
  weight = 'regular',
}: {
  name: SymbolViewProps['name'];
  size?: number;
  color: string;
  style?: StyleProp<ViewStyle>;
  weight?: SymbolWeight;
}) {
  return (
    <SymbolView
      weight={weight}
      tintColor={color}
      resizeMode="scaleAspectFit"
      name={name}
      style={[
        {
          width: size,
          height: size,
        },
        style,
      ]}
    />
  );
}

================
File: components/ui/IconSymbol.tsx
================
// This file is a fallback for using MaterialIcons on Android and web.

import MaterialIcons from '@expo/vector-icons/MaterialIcons';
import { SymbolWeight } from 'expo-symbols';
import React from 'react';
import { OpaqueColorValue, StyleProp, ViewStyle } from 'react-native';

// Add your SFSymbol to MaterialIcons mappings here.
const MAPPING = {
  // See MaterialIcons here: https://icons.expo.fyi
  // See SF Symbols in the SF Symbols app on Mac.
  'house.fill': 'home',
  'paperplane.fill': 'send',
  'chevron.left.forwardslash.chevron.right': 'code',
  'chevron.right': 'chevron-right',
} as Partial<
  Record<
    import('expo-symbols').SymbolViewProps['name'],
    React.ComponentProps<typeof MaterialIcons>['name']
  >
>;

export type IconSymbolName = keyof typeof MAPPING;

/**
 * An icon component that uses native SFSymbols on iOS, and MaterialIcons on Android and web. This ensures a consistent look across platforms, and optimal resource usage.
 *
 * Icon `name`s are based on SFSymbols and require manual mapping to MaterialIcons.
 */
export function IconSymbol({
  name,
  size = 24,
  color,
  style,
}: {
  name: IconSymbolName;
  size?: number;
  color: string | OpaqueColorValue;
  style?: StyleProp<ViewStyle>;
  weight?: SymbolWeight;
}) {
  return <MaterialIcons color={color} size={size} name={MAPPING[name]} style={style} />;
}

================
File: components/ui/TabBarBackground.ios.tsx
================
import { useBottomTabBarHeight } from '@react-navigation/bottom-tabs';
import { BlurView } from 'expo-blur';
import { StyleSheet } from 'react-native';
import { useSafeAreaInsets } from 'react-native-safe-area-context';

export default function BlurTabBarBackground() {
  return (
    <BlurView
      // System chrome material automatically adapts to the system's theme
      // and matches the native tab bar appearance on iOS.
      tint="systemChromeMaterial"
      intensity={100}
      style={StyleSheet.absoluteFill}
    />
  );
}

export function useBottomTabOverflow() {
  const tabHeight = useBottomTabBarHeight();
  const { bottom } = useSafeAreaInsets();
  return tabHeight - bottom;
}

================
File: components/ui/TabBarBackground.tsx
================
// This is a shim for web and Android where the tab bar is generally opaque.
export default undefined;

export function useBottomTabOverflow() {
  return 0;
}

================
File: components/Collapsible.tsx
================
import { PropsWithChildren, useState } from 'react';
import { StyleSheet, TouchableOpacity } from 'react-native';

import { ThemedText } from '@/components/ThemedText';
import { ThemedView } from '@/components/ThemedView';
import { IconSymbol } from '@/components/ui/IconSymbol';
import { Colors } from '@/constants/Colors';
import { useColorScheme } from '@/hooks/useColorScheme';

export function Collapsible({ children, title }: PropsWithChildren & { title: string }) {
  const [isOpen, setIsOpen] = useState(false);
  const theme = useColorScheme() ?? 'light';

  return (
    <ThemedView>
      <TouchableOpacity
        style={styles.heading}
        onPress={() => setIsOpen((value) => !value)}
        activeOpacity={0.8}>
        <IconSymbol
          name="chevron.right"
          size={18}
          weight="medium"
          color={theme === 'light' ? Colors.light.icon : Colors.dark.icon}
          style={{ transform: [{ rotate: isOpen ? '90deg' : '0deg' }] }}
        />

        <ThemedText type="defaultSemiBold">{title}</ThemedText>
      </TouchableOpacity>
      {isOpen && <ThemedView style={styles.content}>{children}</ThemedView>}
    </ThemedView>
  );
}

const styles = StyleSheet.create({
  heading: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 6,
  },
  content: {
    marginTop: 6,
    marginLeft: 24,
  },
});

================
File: components/ExternalLink.tsx
================
import { Link } from 'expo-router';
import { openBrowserAsync } from 'expo-web-browser';
import { type ComponentProps } from 'react';
import { Platform } from 'react-native';

type Props = Omit<ComponentProps<typeof Link>, 'href'> & { href: string };

export function ExternalLink({ href, ...rest }: Props) {
  return (
    <Link
      target="_blank"
      {...rest}
      href={href}
      onPress={async (event) => {
        if (Platform.OS !== 'web') {
          // Prevent the default behavior of linking to the default browser on native.
          event.preventDefault();
          // Open the link in an in-app browser.
          await openBrowserAsync(href);
        }
      }}
    />
  );
}

================
File: components/HapticTab.tsx
================
import { BottomTabBarButtonProps } from '@react-navigation/bottom-tabs';
import { PlatformPressable } from '@react-navigation/elements';
import * as Haptics from 'expo-haptics';

export function HapticTab(props: BottomTabBarButtonProps) {
  return (
    <PlatformPressable
      {...props}
      onPressIn={(ev) => {
        if (process.env.EXPO_OS === 'ios') {
          // Add a soft haptic feedback when pressing down on the tabs.
          Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
        }
        props.onPressIn?.(ev);
      }}
    />
  );
}

================
File: components/HelloWave.tsx
================
import { useEffect } from 'react';
import { StyleSheet } from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withTiming,
  withRepeat,
  withSequence,
} from 'react-native-reanimated';

import { ThemedText } from '@/components/ThemedText';

export function HelloWave() {
  const rotationAnimation = useSharedValue(0);

  useEffect(() => {
    rotationAnimation.value = withRepeat(
      withSequence(withTiming(25, { duration: 150 }), withTiming(0, { duration: 150 })),
      4 // Run the animation 4 times
    );
  }, []);

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [{ rotate: `${rotationAnimation.value}deg` }],
  }));

  return (
    <Animated.View style={animatedStyle}>
      <ThemedText style={styles.text}>👋</ThemedText>
    </Animated.View>
  );
}

const styles = StyleSheet.create({
  text: {
    fontSize: 28,
    lineHeight: 32,
    marginTop: -6,
  },
});

================
File: components/ParallaxScrollView.tsx
================
import type { PropsWithChildren, ReactElement } from 'react';
import { StyleSheet } from 'react-native';
import Animated, {
  interpolate,
  useAnimatedRef,
  useAnimatedStyle,
  useScrollViewOffset,
} from 'react-native-reanimated';

import { ThemedView } from '@/components/ThemedView';
import { useBottomTabOverflow } from '@/components/ui/TabBarBackground';
import { useColorScheme } from '@/hooks/useColorScheme';

const HEADER_HEIGHT = 250;

type Props = PropsWithChildren<{
  headerImage: ReactElement;
  headerBackgroundColor: { dark: string; light: string };
}>;

export default function ParallaxScrollView({
  children,
  headerImage,
  headerBackgroundColor,
}: Props) {
  const colorScheme = useColorScheme() ?? 'light';
  const scrollRef = useAnimatedRef<Animated.ScrollView>();
  const scrollOffset = useScrollViewOffset(scrollRef);
  const bottom = useBottomTabOverflow();
  const headerAnimatedStyle = useAnimatedStyle(() => {
    return {
      transform: [
        {
          translateY: interpolate(
            scrollOffset.value,
            [-HEADER_HEIGHT, 0, HEADER_HEIGHT],
            [-HEADER_HEIGHT / 2, 0, HEADER_HEIGHT * 0.75]
          ),
        },
        {
          scale: interpolate(scrollOffset.value, [-HEADER_HEIGHT, 0, HEADER_HEIGHT], [2, 1, 1]),
        },
      ],
    };
  });

  return (
    <ThemedView style={styles.container}>
      <Animated.ScrollView
        ref={scrollRef}
        scrollEventThrottle={16}
        scrollIndicatorInsets={{ bottom }}
        contentContainerStyle={{ paddingBottom: bottom }}>
        <Animated.View
          style={[
            styles.header,
            { backgroundColor: headerBackgroundColor[colorScheme] },
            headerAnimatedStyle,
          ]}>
          {headerImage}
        </Animated.View>
        <ThemedView style={styles.content}>{children}</ThemedView>
      </Animated.ScrollView>
    </ThemedView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    height: HEADER_HEIGHT,
    overflow: 'hidden',
  },
  content: {
    flex: 1,
    padding: 32,
    gap: 16,
    overflow: 'hidden',
  },
});

================
File: components/ThemedText.tsx
================
import { Text, type TextProps, StyleSheet } from 'react-native';

import { useThemeColor } from '@/hooks/useThemeColor';

export type ThemedTextProps = TextProps & {
  lightColor?: string;
  darkColor?: string;
  type?: 'default' | 'title' | 'defaultSemiBold' | 'subtitle' | 'link';
};

export function ThemedText({
  style,
  lightColor,
  darkColor,
  type = 'default',
  ...rest
}: ThemedTextProps) {
  const color = useThemeColor({ light: lightColor, dark: darkColor }, 'text');

  return (
    <Text
      style={[
        { color },
        type === 'default' ? styles.default : undefined,
        type === 'title' ? styles.title : undefined,
        type === 'defaultSemiBold' ? styles.defaultSemiBold : undefined,
        type === 'subtitle' ? styles.subtitle : undefined,
        type === 'link' ? styles.link : undefined,
        style,
      ]}
      {...rest}
    />
  );
}

const styles = StyleSheet.create({
  default: {
    fontSize: 16,
    lineHeight: 24,
  },
  defaultSemiBold: {
    fontSize: 16,
    lineHeight: 24,
    fontWeight: '600',
  },
  title: {
    fontSize: 32,
    fontWeight: 'bold',
    lineHeight: 32,
  },
  subtitle: {
    fontSize: 20,
    fontWeight: 'bold',
  },
  link: {
    lineHeight: 30,
    fontSize: 16,
    color: '#0a7ea4',
  },
});

================
File: components/ThemedView.tsx
================
import { View, type ViewProps } from 'react-native';

import { useThemeColor } from '@/hooks/useThemeColor';

export type ThemedViewProps = ViewProps & {
  lightColor?: string;
  darkColor?: string;
};

export function ThemedView({ style, lightColor, darkColor, ...otherProps }: ThemedViewProps) {
  const backgroundColor = useThemeColor({ light: lightColor, dark: darkColor }, 'background');

  return <View style={[{ backgroundColor }, style]} {...otherProps} />;
}

================
File: constants/Colors.ts
================
/**
 * Below are the colors that are used in the app. The colors are defined in the light and dark mode.
 * There are many other ways to style your app. For example, [Nativewind](https://www.nativewind.dev/), [Tamagui](https://tamagui.dev/), [unistyles](https://reactnativeunistyles.vercel.app), etc.
 */

const tintColorLight = '#0a7ea4';
const tintColorDark = '#fff';

export const Colors = {
  light: {
    text: '#11181C',
    background: '#fff',
    tint: tintColorLight,
    icon: '#687076',
    tabIconDefault: '#687076',
    tabIconSelected: tintColorLight,
  },
  dark: {
    text: '#ECEDEE',
    background: '#151718',
    tint: tintColorDark,
    icon: '#9BA1A6',
    tabIconDefault: '#9BA1A6',
    tabIconSelected: tintColorDark,
  },
};

================
File: constants/roles.ts
================
export interface Role {
  name: string;
  description: string;
}

export const roles: { [key: string]: Role } = {
  werewolf: {
    name: "Loup-Garou",
    description:
      "Chaque nuit, votez avec les autres loups-garous pour dévorer un villageois",
  },
  villager: {
    name: "Villageois",
    description:
      "Votez pendant la journée pour éliminer les loups-garous suspects",
  },
  seer: {
    name: "Voyante",
    description:
      "Chaque nuit, inspectez un joueur pour découvrir s'il est un loup-garou",
  },
  cupid: {
    name: "Cupidon",
    description:
      "La première nuit, choisissez deux joueurs qui tomberont amoureux. Si l'un meurt, l'autre meurt aussi.",
  },
  hunter: {
    name: "Chasseur",
    description:
      "Si vous mourez, vous pouvez immédiatement tuer un autre joueur en utilisant votre dernière balle",
  },
  witch: {
    name: "Sorcière",
    description:
      "Vous avez deux potions : une pour sauver un joueur tué par les loups-garous, une pour éliminer un joueur. Utilisable une seule fois chacune",
  },
  littleGirl: {
    name: "Petite Fille",
    description:
      "Chaque nuit, vous pouvez espionner les loups-garous, mais attention à ne pas vous faire repérer",
  },
};

export function getRoleDescription(roleName: string): string | undefined {
  const role = roles[roleName];
  return role ? role.description : undefined;
}

================
File: hooks/useColorScheme.ts
================
export { useColorScheme } from 'react-native';

================
File: hooks/useColorScheme.web.ts
================
import { useEffect, useState } from 'react';
import { useColorScheme as useRNColorScheme } from 'react-native';

/**
 * To support static rendering, this value needs to be re-calculated on the client side for web
 */
export function useColorScheme() {
  const [hasHydrated, setHasHydrated] = useState(false);

  useEffect(() => {
    setHasHydrated(true);
  }, []);

  const colorScheme = useRNColorScheme();

  if (hasHydrated) {
    return colorScheme;
  }

  return 'light';
}

================
File: hooks/useThemeColor.ts
================
/**
 * Learn more about light and dark modes:
 * https://docs.expo.dev/guides/color-schemes/
 */

import { Colors } from '@/constants/Colors';
import { useColorScheme } from '@/hooks/useColorScheme';

export function useThemeColor(
  props: { light?: string; dark?: string },
  colorName: keyof typeof Colors.light & keyof typeof Colors.dark
) {
  const theme = useColorScheme() ?? 'light';
  const colorFromProps = props[theme];

  if (colorFromProps) {
    return colorFromProps;
  } else {
    return Colors[theme][colorName];
  }
}

================
File: scripts/reset-project.js
================
#!/usr/bin/env node

/**
 * This script is used to reset the project to a blank state.
 * It moves the /app, /components, /hooks, /scripts, and /constants directories to /app-example and creates a new /app directory with an index.tsx and _layout.tsx file.
 * You can remove the `reset-project` script from package.json and safely delete this file after running it.
 */

const fs = require("fs");
const path = require("path");

const root = process.cwd();
const oldDirs = ["app", "components", "hooks", "constants", "scripts"];
const newDir = "app-example";
const newAppDir = "app";
const newDirPath = path.join(root, newDir);

const indexContent = `import { Text, View } from "react-native";

export default function Index() {
  return (
    <View
      style={{
        flex: 1,
        justifyContent: "center",
        alignItems: "center",
      }}
    >
      <Text>Edit app/index.tsx to edit this screen.</Text>
    </View>
  );
}
`;

const layoutContent = `import { Stack } from "expo-router";

export default function RootLayout() {
  return <Stack />;
}
`;

const moveDirectories = async () => {
  try {
    // Create the app-example directory
    await fs.promises.mkdir(newDirPath, { recursive: true });
    console.log(`📁 /${newDir} directory created.`);

    // Move old directories to new app-example directory
    for (const dir of oldDirs) {
      const oldDirPath = path.join(root, dir);
      const newDirPath = path.join(root, newDir, dir);
      if (fs.existsSync(oldDirPath)) {
        await fs.promises.rename(oldDirPath, newDirPath);
        console.log(`➡️ /${dir} moved to /${newDir}/${dir}.`);
      } else {
        console.log(`➡️ /${dir} does not exist, skipping.`);
      }
    }

    // Create new /app directory
    const newAppDirPath = path.join(root, newAppDir);
    await fs.promises.mkdir(newAppDirPath, { recursive: true });
    console.log("\n📁 New /app directory created.");

    // Create index.tsx
    const indexPath = path.join(newAppDirPath, "index.tsx");
    await fs.promises.writeFile(indexPath, indexContent);
    console.log("📄 app/index.tsx created.");

    // Create _layout.tsx
    const layoutPath = path.join(newAppDirPath, "_layout.tsx");
    await fs.promises.writeFile(layoutPath, layoutContent);
    console.log("📄 app/_layout.tsx created.");

    console.log("\n✅ Project reset complete. Next steps:");
    console.log(
      "1. Run `npx expo start` to start a development server.\n2. Edit app/index.tsx to edit the main screen.\n3. Delete the /app-example directory when you're done referencing it."
    );
  } catch (error) {
    console.error(`Error during script execution: ${error}`);
  }
};

moveDirectories();

================
File: utils/config.js
================
export const backendUrl = process.env.EXPO_PUBLIC_BACKEND_URL;

================
File: utils/sockets.js
================
import { io } from "socket.io-client";
import { backendUrl } from "@/utils/config";

export const socket = io(backendUrl, {
  autoConnect: true,
  transports: ["websocket"],
});

//window.socket = socket;

socket.on("connect", () => {
  console.log("Socket connected");
});

socket.on("connect_error", (error) => {
  console.log("Socket connection error:", error);
});

================
File: .gitignore
================
# Learn more https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files

# dependencies
node_modules/

# Expo
.expo/
dist/
web-build/
expo-env.d.ts

# Native
*.orig.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision

# Metro
.metro-health-check*

# debug
npm-debug.*
yarn-debug.*
yarn-error.*

# macOS
.DS_Store
*.pem

# local env files
.env*.local

# typescript
*.tsbuildinfo

app-example
.env\n

================
File: app.json
================
{
  "expo": {
    "extra": {
      "ipAddr": "192.168.2.215"
    },
    "name": "loup-garou-frontend",
    "slug": "loup-garou-frontend",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/images/icon.png",
    "scheme": "myapp",
    "userInterfaceStyle": "automatic",
    "newArchEnabled": true,
    "ios": {
      "supportsTablet": true
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/images/adaptive-icon.png",
        "backgroundColor": "#ffffff"
      }
    },
    "web": {
      "bundler": "metro",
      "output": "static",
      "favicon": "./assets/images/favicon.png"
    },
    "plugins": [
      "expo-router",
      [
        "expo-splash-screen",
        {
          "image": "./assets/images/splash-icon.png",
          "imageWidth": 200,
          "resizeMode": "contain",
          "backgroundColor": "#ffffff"
        }
      ]
    ],
    "experiments": {
      "typedRoutes": true
    }
  }
}

================
File: babel.config.js
================
module.exports = function (api) {
  api.cache(true);
  return {
    presets: [
      ["babel-preset-expo", { jsxImportSource: "nativewind" }],
      "nativewind/babel",
    ],
  };
};

================
File: global.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

================
File: metro.config.js
================
const { getDefaultConfig } = require("expo/metro-config");
const { withNativeWind } = require('nativewind/metro');
const config = getDefaultConfig(__dirname)
module.exports = withNativeWind(config, { input: './global.css' })

================
File: nativewind-env.d.ts
================
/// <reference types="nativewind/types" />

// NOTE: This file should not be edited and should be committed with your source code. It is generated by NativeWind.

================
File: notes.txt
================
L'alert pour commencer le segment des loups garou ne marche pas
j'ai implementer une fonction emit test dans le frontend directement mais ca ne trigger pas
je ne sais pas pourquoi

================
File: package.json
================
{
  "name": "loup-garou-frontend",
  "main": "expo-router/entry",
  "version": "1.0.0",
  "scripts": {
    "start": "expo start",
    "reset-project": "node ./scripts/reset-project.js",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web",
    "test": "jest --watchAll",
    "lint": "expo lint"
  },
  "jest": {
    "preset": "jest-expo"
  },
  "dependencies": {
    "@expo/vector-icons": "^14.0.2",
    "@lottiefiles/dotlottie-react": "^0.6.5",
    "@react-native-picker/picker": "^2.11.0",
    "@react-navigation/bottom-tabs": "^7.2.0",
    "@react-navigation/native": "^7.0.14",
    "axios": "^1.7.9",
    "expo": "~52.0.23",
    "expo-blur": "~14.0.1",
    "expo-constants": "~17.0.3",
    "expo-font": "~13.0.2",
    "expo-haptics": "~14.0.0",
    "expo-linking": "~7.0.3",
    "expo-router": "~4.0.15",
    "expo-splash-screen": "~0.29.18",
    "expo-status-bar": "~2.0.0",
    "expo-symbols": "~0.2.0",
    "expo-system-ui": "~4.0.6",
    "expo-web-browser": "~14.0.1",
    "lottie-react-native": "7.1.0",
    "moti": "^0.29.0",
    "nativewind": "^4.1.23",
    "react": "18.3.1",
    "react-dom": "18.3.1",
    "react-native": "0.76.5",
    "react-native-gesture-handler": "~2.20.2",
    "react-native-reanimated": "~3.16.1",
    "react-native-safe-area-context": "^4.14.1",
    "react-native-screens": "~4.4.0",
    "react-native-svg": "15.8.0",
    "react-native-web": "~0.19.13",
    "react-native-websocket": "^1.0.2",
    "react-native-webview": "13.12.5",
    "socket.io-client": "^4.8.1",
    "tailwindcss": "^3.4.17"
  },
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@types/jest": "^29.5.12",
    "@types/react": "~18.3.12",
    "@types/react-native": "^0.72.8",
    "@types/react-test-renderer": "^18.3.0",
    "jest": "^29.2.1",
    "jest-expo": "~52.0.2",
    "react-test-renderer": "18.3.1",
    "typescript": "^5.3.3"
  },
  "private": true
}

================
File: README.md
================
# Welcome to your Expo app 👋

This is an [Expo](https://expo.dev) project created with [`create-expo-app`](https://www.npmjs.com/package/create-expo-app).

## Get started

1. Install dependencies

   ```bash
   npm install
   ```

2. Start the app

   ```bash
    npx expo start
   ```

In the output, you'll find options to open the app in a

- [development build](https://docs.expo.dev/develop/development-builds/introduction/)
- [Android emulator](https://docs.expo.dev/workflow/android-studio-emulator/)
- [iOS simulator](https://docs.expo.dev/workflow/ios-simulator/)
- [Expo Go](https://expo.dev/go), a limited sandbox for trying out app development with Expo

You can start developing by editing the files inside the **app** directory. This project uses [file-based routing](https://docs.expo.dev/router/introduction).

## Get a fresh project

When you're ready, run:

```bash
npm run reset-project
```

This command will move the starter code to the **app-example** directory and create a blank **app** directory where you can start developing.

## Learn more

To learn more about developing your project with Expo, look at the following resources:

- [Expo documentation](https://docs.expo.dev/): Learn fundamentals, or go into advanced topics with our [guides](https://docs.expo.dev/guides).
- [Learn Expo tutorial](https://docs.expo.dev/tutorial/introduction/): Follow a step-by-step tutorial where you'll create a project that runs on Android, iOS, and the web.

## Join the community

Join our community of developers creating universal apps.

- [Expo on GitHub](https://github.com/expo/expo): View our open source platform and contribute.
- [Discord community](https://chat.expo.dev): Chat with Expo users and ask questions.
# loup-garou

================
File: tailwind.config.js
================
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: ["./app/**/*.{js,jsx,ts,tsx}", 
"./components/**/*.{js,jsx,ts,tsx}"],
  presets: [require("nativewind/preset")],
  theme: {
    extend: {},
  },
  plugins: [],
}

================
File: tsconfig.json
================
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "paths": {
      "@/*": [
        "./*"
      ]
    }
  },
  "include": [
    "**/*.ts",
    "**/*.tsx",
    ".expo/types/**/*.ts",
    "expo-env.d.ts",
    "nativewind-env.d.ts"
  ]
}

================
File: types.ts
================
export type Player = {
  name: string;
  sid: string;
  role: string;
};
