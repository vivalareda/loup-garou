This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-07T21:03:53.563Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
loup-garou-backend/
  core/
    game.py
    player.py
    roles.py
  segments/
    segment_manager.py
  server/
    app.py
    events.py
  .gitignore
  main.py
  requirements.txt
loup-garou-frontend/
  app/
    (tabs)/
      _layout.tsx
      DayVote.tsx
      Death.tsx
      GameInterface.tsx
      index.tsx
      LoveAlert.tsx
      Seer.tsx
      test-page.tsx
      waiting-room.tsx
      Werewolf.tsx
      WitchHeal.tsx
      WitchKill.tsx
    _layout.tsx
    +not-found.tsx
  components/
    __tests__/
      __snapshots__/
        ThemedText-test.tsx.snap
      ThemedText-test.tsx
    roles/
      Cupidon.tsx
      Hunter.tsx
    ui/
      IconSymbol.ios.tsx
      IconSymbol.tsx
      TabBarBackground.ios.tsx
      TabBarBackground.tsx
    Collapsible.tsx
    ExternalLink.tsx
    HapticTab.tsx
    HelloWave.tsx
    ParallaxScrollView.tsx
    ThemedText.tsx
    ThemedView.tsx
  constants/
    Colors.ts
    roles.ts
  hooks/
    useColorScheme.ts
    useColorScheme.web.ts
    useThemeColor.ts
  scripts/
    reset-project.js
  utils/
    config.js
    sockets.js
  .env
  .gitignore
  app.json
  babel.config.js
  global.css
  metro.config.js
  nativewind-env.d.ts
  notes.txt
  package.json
  README.md
  tailwind.config.js
  tsconfig.json
  types.ts
README.md

================================================================
Repository Files
================================================================

================
File: loup-garou-backend/core/game.py
================
import random
from typing import Dict, List, Optional

from .player import Player
from .roles import ROLE_DESCRIPTIONS, PlayerRole


class Game:
    def __init__(self):
        self.players: Dict[str, Player] = {}
        self.pending_deaths: List[str] = []
        self.witch_heal_available = True
        self.witch_kill_available = True
        self.lovers: List[Player] = []
        self.veto_player = None
        self.player_votes_count: Dict[str, int] = {}
        self.werewolves_alive = 0
        self.villagers_alive = 0
        self.winners = None

    def add_player(self, name: str, sid: str) -> Player:
        player = Player(name=name, sid=sid)
        self.players[sid] = player
        return player

    def add_mock_players(self, count: int):
        mock_names = ["Alice", "Bob", "Charlie", "Eve"]
        for i, name in enumerate(mock_names[:count]):
            mock_sid = f"mock_{i}"
            self.add_player(name, mock_sid)

    def get_player(self, sid: str) -> Optional[Player]:
        return self.players.get(sid)

    def get_player_by_role(self, role: PlayerRole) -> Optional[Player]:
        return next((p for p in self.players.values() if p.role == role), None)

    def get_players_by_role(self, role: PlayerRole) -> List[Player]:
        return [p for p in self.players.values() if p.role == role]

    def assign_roles(self):
        # TODO: Uncomment werewolves and increate number to 5, removed to assign to specific player for testing
        num_players = len(self.players)
        roles_to_assign = [
            # PlayerRole.WEREWOLF,
            # PlayerRole.WEREWOLF,
            # PlayerRole.WITCH,
            PlayerRole.SEER,
            PlayerRole.CUPID,
        ] + [PlayerRole.VILLAGER] * (num_players - 2)

        random.shuffle(roles_to_assign)
        print("All players : ", self.players.values())
        for player, role in zip(self.players.values(), roles_to_assign):
            if player.name == "reda":
                self.cupid = player.sid
                role = PlayerRole.WEREWOLF
                self.set_veto_player(player.sid)
                player.role = role
            elif player.name == "carl":
                role = PlayerRole.WITCH
                player.role = role
            else:
                player.role = role

    def set_lovers(self, player1: Player, player2: Player):
        player1.lover_sid = player2.sid
        player2.lover_sid = player1.sid
        self.lovers = [player1, player2]

    def get_lovers(self) -> List[Player]:
        return self.lovers

    def add_pending_death(self, player: Player):
        if player.sid not in self.pending_deaths:
            self.pending_deaths.append(player.sid)

    def remove_pending_death(self, player: Player):
        if player.sid in self.pending_deaths:
            self.pending_deaths.remove(player.sid)

    def set_veto_player(self, player_sid: str):
        self.veto_player = player_sid

    def set_player_vote(self, player_sid: str):
        print("The player voted is : ", player_sid)
        if player_sid in self.player_votes_count:
            self.player_votes_count[player_sid] += 1
        else:
            self.player_votes_count[player_sid] = 1

        dict(
            sorted(self.player_votes_count.items(), key=lambda item: item[1]),
            reverse=True,
        )

    def annouce_death(self, player_sid: str):
        player = self.get_player(player_sid)
        if not player:
            raise ValueError("Invalid target player")
        if player.lover_sid:
            lover = self.get_player(player.lover_sid)
            if lover:
                lover.is_alive = False
        player.is_alive = False

    def get_top_voted_players(self) -> List[str]:
        if not self.player_votes_count:
            return []
        max_votes = next(iter(self.player_votes_count.values()))
        top_players = [
            player
            for player, votes in self.player_votes_count.items()
            if votes == max_votes
        ]
        return top_players

    def get_werewolves_count(self):
        return len(self.get_players_by_role(PlayerRole.WEREWOLF))

    def reset_player_votes(self):
        self.player_votes_count = {}

    def game_over(self):
        werewolves = len(self.get_players_by_role(PlayerRole.WEREWOLF))
        if werewolves == 0:
            self.winners = "Villagers"
            return True
        if werewolves >= self.villagers_alive:
            self.winners = "Werewolves"
            return True
        return False

================
File: loup-garou-backend/core/player.py
================
from dataclasses import dataclass
from typing import Optional

from .roles import PlayerRole


@dataclass
class Player:
    name: str
    sid: str
    role: Optional[PlayerRole] = None
    is_alive: bool = True
    lover_sid: Optional[str] = None

    def to_dict(self):
        return {
            "name": self.name,
            "sid": self.sid,
            "role": self.role.value if self.role else None,
            "is_alive": self.is_alive,
        }

    def __repr__(self):
        role_name = self.role if self.role else "No role assigned"
        return f"{self.name} is a {role_name}, current alive status: {self.is_alive}"

================
File: loup-garou-backend/core/roles.py
================
from enum import Enum


class PlayerRole(Enum):
    VILLAGER = "villager"
    WEREWOLF = "werewolf"
    WITCH = "witch"
    SEER = "seer"
    HUNTER = "hunter"
    CUPID = "cupid"


class Role:
    def __init__(self, name, description, team):
        self.name = name
        self.description = description
        self.team = team


ROLE_DESCRIPTIONS = {
    PlayerRole.WEREWOLF: Role(
        "Werewolf",
        "Each night, vote with other werewolves to eat a villager",
        "Werewolf",
    ),
    PlayerRole.VILLAGER: Role(
        "Villager", "Vote during the day to eliminate suspected werewolves", "Villager"
    ),
    PlayerRole.SEER: Role(
        "Seer",
        "Each night, check one player to reveal if they are a werewolf",
        "Villager",
    ),
    PlayerRole.CUPID: Role(
        "Cupidon",
        "On the first night, choose two players to fall in love. If one dies, the other dies too.",
        "Villager",
    ),
    PlayerRole.HUNTER: Role(
        "Hunter", "If you die, you can choose to take someone down with you", "Villager"
    ),
    PlayerRole.WITCH: Role(
        "Witch",
        "You have two potions: one to save, one to kill. Use each only once.",
        "Villager",
    ),
}

================
File: loup-garou-backend/segments/segment_manager.py
================
# segments/segment_manager.py
from enum import Enum

from playsound import playsound

from core.roles import PlayerRole


class SegmentType(Enum):
    CUPID = "cupid"
    LOVERS = "lovers"
    WEREWOLF = "werewolf"
    WITCH_HEAL = "witch_heal"
    WITCH_KILL = "witch_kill"
    SEER = "seer"
    DAY = "day"


class SegmentManager:
    def __init__(self, game, socketio):
        self.first_night = True
        self.game = game
        self.socketio = socketio
        self.current_segment = -1
        self.segment_order = [
            SegmentType.CUPID,
            SegmentType.LOVERS,
            SegmentType.WEREWOLF,
            SegmentType.WITCH_HEAL,
            SegmentType.WITCH_KILL,
            SegmentType.SEER,
            SegmentType.DAY,
        ]

    def play_audio(self, filename):
        try:
            playsound(f"./assets/{filename}.mp3")
        except Exception as e:
            print(e)

    def play_start_audio(self, segment):
        if segment == SegmentType.CUPID:
            self.play_audio("Cupidon/Cupidon-1")
        if segment == SegmentType.LOVERS:
            self.play_audio("Lovers/Lover-1")
        elif segment == SegmentType.WEREWOLF:
            self.play_audio("Werewolves/Werewolves-1")
        elif segment == SegmentType.WITCH_HEAL:
            self.play_audio("Sorciere-1")
        elif segment == SegmentType.WITCH_KILL:
            self.play_audio("Sorciere-2")

    def start_night(self):
        self.current_segment = 0
        print("Starting night")
        # TODO: Uncomment this line to play the intro audio
        self.play_audio("Intro")
        self.run_current_segment()

    def run_current_segment(self):
        segment = self.segment_order[self.current_segment]
        print("running segment", segment)
        if segment == SegmentType.CUPID:
            if not self.first_night:
                self.advance_segment()
            # print("running cupid segment")
            self._run_cupid_segment()
            # self.advance_segment()  # TODO remove this when want cupid to run
        elif segment == SegmentType.LOVERS:
            self._run_lovers_segment()
            # self.advance_segment()  # TODO remove this when want cupid to run
        elif segment == SegmentType.WEREWOLF:
            print("running_werewolf")
            self._run_werewolf_segment()
        elif segment == SegmentType.WITCH_HEAL:
            self.advance_segment()  # TODO remove this when want cupid to run
            # self._run_witch_heal_segment()
        elif segment == SegmentType.WITCH_KILL:
            # self.advance_segment()  # TODO remove this when want cupid to run
            self._run_witch_kill_segment()
        elif segment == SegmentType.SEER:
            self.advance_segment()
            # self._run_seer_segment()
        elif segment == SegmentType.DAY:
            self.night_finished()

    def advance_segment(self):
        print("current segment is ", self.current_segment)
        if self.current_segment == 0 and self.first_night:
            self.play_audio("Cupidon/Cupidon-2")
        if self.current_segment == 1 and self.first_night:
            self.play_audio("Lovers/Lover-3")
        if self.current_segment == 2:
            self.play_audio("Werewolves/Werewolves-2")
            print("played werewolves")
        if self.current_segment == 4:
            self.play_audio("Sorciere-3")
        if self.current_segment == 5:
            self.play_audio("Wake-up-everyone")
        self.current_segment = (self.current_segment + 1) % len(self.segment_order)
        self.run_current_segment()

    def _run_cupid_segment(self):
        print("stating here")
        self.play_start_audio(SegmentType.CUPID)
        # TODO : uncomment this and remove the hard coded value this is how to get cupid player
        # cupid = self.game.get_player_by_role(PlayerRole.CUPID)
        print("cupid sid", self.game.cupid)

        self.socketio.emit(
            "cupidon_choice",
            {"message": "Choose two players to fall in love"},
            to=self.game.cupid,
            # CHANGE to cupid.sid
        )

    def _run_werewolf_segment(self):
        self.play_start_audio(SegmentType.WEREWOLF)
        werewolves = self.game.get_players_by_role(PlayerRole.WEREWOLF)
        for werewolf in werewolves:
            other_werewolves = [w for w in werewolves if w.sid != werewolf.sid]
            self.socketio.emit(
                "werewolf_wake_up",
                {
                    "message": "Choose a victim",
                    "other_werewolves": [w.name for w in other_werewolves],
                },
                to=werewolf.sid,
            )

    def _run_witch_heal_segment(self):
        if not self.game.witch_heal_available:
            return
        self.play_start_audio(SegmentType.WITCH_HEAL)
        witch = self.game.get_player_by_role(PlayerRole.WITCH)
        if witch and witch.is_alive and self.game.witch_heal_available:
            last_victim = None
            if self.game.pending_deaths:
                last_victim = self.game.get_player(self.game.pending_deaths[-1])

            if last_victim:
                try:
                    self.socketio.emit(
                        "witch_heal",
                        {
                            "message": "Make your choice",
                            "victim": last_victim.name if last_victim else None,
                        },
                        to=witch.sid,
                    )
                except Exception as e:
                    print(e)

    def _run_witch_kill_segment(self):
        if not self.game.witch_kill_available:
            return
        self.play_start_audio(SegmentType.WITCH_KILL)
        witch = self.game.get_player_by_role(PlayerRole.WITCH)
        print("witch kill available")
        if witch and witch.is_alive and self.game.witch_kill_available:
            try:
                self.socketio.emit(
                    "witch_kill",
                    {
                        "message": "Choose a player to kill",
                    },
                    to=witch.sid,
                )
            except Exception as e:
                print(e)

    def _run_seer_segment(self):
        self.play_start_audio(SegmentType.SEER)
        seer = self.game.get_player_by_role(PlayerRole.SEER)
        if seer:
            self.socketio.emit(
                "seer_choice",
                {"message": "Choose a player to investigate"},
                to=seer.sid,
            )

    def night_finished(self):
        print("Pending death ", len(self.game.pending_deaths))
        self.first_night = False
        if len(self.game.pending_deaths) == 0:
            self.play_audio("Night-end/No-deaths")
        else:
            self.play_audio("Night-end/Deaths")
            print(self.game.pending_deaths)
            for sid in self.game.pending_deaths:
                player = self.game.get_player(sid)
                player.is_alive = False
                self.alert_dead_player(player)

        self.start_day_vote()

    def start_day_vote(self):
        self.socketio.sleep(1)
        print("Starting day vote")
        self.socketio.emit("day_vote")

    def count_votes(self):
        top_player = self.game.get_top_voted_player()
        if len(top_player) == 1:
            player = self.game.get_player(top_player[0])
            if player.lover_sid:
                self.alert_dead_player(player.lover_sid)
            self.alert_dead_player(top_player[0])

    def _run_lovers_segment(self):
        self.play_start_audio(SegmentType.LOVERS)
        lovers = self.game.get_lovers()
        player1, player2 = lovers
        self.socketio.emit("alert_lovers", {"lover": player2.name}, to=player1.sid)
        self.socketio.emit("alert_lovers", {"lover": player1.name}, to=player2.sid)

        self.play_audio("Lovers/Lover-2")

        self.socketio.emit("lover_can_close", to=player1.sid)
        self.socketio.emit("lover_can_close", to=player2.sid)

    def alert_dead_player(self, player):
        print("Alerting dead player", player.sid)
        try:
            self.socketio.emit("alert_dead", to=player.sid)
        except Exception as e:
            print(e)

    def reset_current_segment(self):
        current_segment = -1

================
File: loup-garou-backend/server/app.py
================
from flask import Flask
from flask_socketio import SocketIO

from core.game import Game
from segments.segment_manager import SegmentManager

from .events import GameEvents


def create_app():
    app = Flask(__name__)
    socketio = SocketIO(app, cors_allowed_origins="*")

    game = Game()
    segment_manager = SegmentManager(game, socketio)
    events = GameEvents(game, segment_manager, app, socketio)
    events.register_handlers()

    return app, socketio

================
File: loup-garou-backend/server/events.py
================
from flask import jsonify, request

from core.roles import PlayerRole


class GameEvents:
    def __init__(self, game, segment_manager, app, socketio):
        self.game = game
        self.segments = segment_manager
        self.app = app
        self.lover_alerts_closed = 0
        self.kill_votes_count = 2
        self.alive_players_count = 0
        self.socketio = socketio

    def register_handlers(self):

        @self.app.route("/players", methods=["GET"])
        def get_players():
            try:
                print("Players: ", self.game.players)
                return (
                    jsonify(
                        {"players": [p.to_dict() for p in self.game.players.values()]}
                    ),
                    200,
                )
            except Exception as e:
                return jsonify({"error": str(e)}), 500

        @self.app.route("/get_werewolves", methods=["GET"])
        def get_werewolves():
            try:
                werewolves = self.game.get_players_by_role(PlayerRole.WEREWOLF)
                return jsonify({"werewolves": [w.to_dict() for w in werewolves]}), 200
            except Exception as e:
                return jsonify({"error": str(e)}), 500

        # Socket Events
        @self.socketio.on("add_player")
        def handle_add_player(data):
            try:
                if "name" not in data:
                    raise ValueError("Player name required")

                player = self.game.add_player(data["name"], request.sid)

                if len(self.game.players) < 5:
                    self.game.add_mock_players(5 - len(self.game.players))

                try:
                    self.socketio.emit("player_data", player.to_dict(), to=request.sid)
                except Exception as e:
                    print("Error in socket emit:", str(e))
                try:
                    self.socketio.emit(
                        "update_players_list",
                        [p.to_dict() for p in self.game.players.values()],
                        room=None,
                    )
                except Exception as e:
                    print("Error in socket emit:", str(e))

                print("Player in game: ", len(self.game.players))

                if len(self.game.players) == 6:
                    print("Assigning roles")
                    self.game.assign_roles()
                    print("Roles assigned")
                    self.alert_player_for_roles()
                    self.segments.start_night()

            except Exception as e:
                self.socketio.emit("error", {"message": str(e)}, to=request.sid)

        @self.socketio.on("cupidon_selection_complete")
        def handle_cupidon_selection(data):
            try:
                sids = [player["sid"] for player in data]
                player1 = self.game.get_player(sids[0])
                player2 = self.game.get_player(sids[1])

                if not player1 or not player2:
                    raise ValueError("Invalid player selection")

                self.game.set_lovers(player1, player2)
                self.segments.advance_segment()

            except Exception as e:
                self.socketio.emit("error", {"message": str(e)}, to=request.sid)

        @self.socketio.on("lover_alert_closed")
        def handle_lover_alert_closed():
            self.lover_alerts_closed += 1
            if self.lover_alerts_closed == 2:
                print("Lover alerts closed")
                self.segments.advance_segment()

        @self.socketio.on("update_werewolf_selection_count")
        def handle_werewolf_selection(data):
            try:
                werewolves = self.game.get_players_by_role(PlayerRole.WEREWOLF)
                for werewolf in werewolves:
                    self.socketio.emit("new_selection_count", data, to=werewolf.sid)
            except Exception as e:
                self.socketio.emit("error", {"message": str(e)}, to=request.sid)

        @self.socketio.on("werewolf_kill")
        def handle_werewolf_kill(data):
            try:
                target = self.game.get_player(data)
                if not target:
                    raise ValueError("Invalid target player")

                if target.lover_sid:
                    lover = self.game.get_player(target.lover_sid)
                    if lover:
                        self.game.add_pending_death(lover)
                self.game.add_pending_death(target)

                print("Pending deaths: ", self.game.pending_deaths)
                self.segments.advance_segment()

            except Exception as e:
                self.socketio.emit("error", {"message": str(e)}, to=request.sid)

        @self.socketio.on("witch_heal_victim")
        def handle_witch_heal_victim():
            try:
                last_victim = self.game.get_player(self.game.pending_deaths[-1])
                if last_victim.lover_sid:
                    self.game.remove_pending_death(last_victim.lover_sid)
                self.game.remove_pending_death(last_victim)

                self.game.witch_heal_available = False
            except Exception as e:
                self.socketio.emit("error", {"message": str(e)}, to=request.sid)
            self.segments.advance_segment()

        @self.socketio.on("witch_kill_victim")
        def handle_witch_kill_victim(data):
            print(data)

            try:
                target_sid = data["sid"]
                target = self.game.get_player(target_sid)
                print("This player will be added to the pending kill list: ", target)

                if target.lover_sid:
                    lover = self.game.get_player(target.lover_sid)
                    if lover:
                        self.game.add_pending_death(lover)
                self.game.add_pending_death(target)

                self.game.witch_kill_available = False
            except Exception as e:
                print("Can't kill witch victim", e)

            self.segments.advance_segment()

        @self.socketio.on("witch_no_heal")
        def handle_witch_no_heal():
            self.segments.advance_segment()

        @self.socketio.on("witch_no_kill")
        def handle_witch_no_kill():
            self.segments.advance_segment()

        @self.socketio.on("vote_kill")
        def handle_vote_kill(data):
            if self.alive_players_count == 0:
                self.set_alive_players_count()
            self.kill_votes_count += 1
            player_sid = data.get("sid")
            self.game.set_player_vote(player_sid)
            print("Kill votes count is now: ", self.kill_votes_count)
            print("Alive players count is: ", self.alive_players_count)

            if self.kill_votes_count == self.alive_players_count:
                self.segments.count_votes()
            self.segments.reset_current_segment()
            if not self.game.game_over():
                self.segments.reset_current_segment()

    def set_alive_players_count(self):
        self.alive_players_count = len(
            [player for player in self.game.players.values() if player.is_alive]
        )

    def alert_player_for_roles(self):
        for player in self.game.players.values():
            print(player)
            try:
                self.socketio.emit(
                    "role_assigned", {"role": player.role.value}, room=player.sid
                )
            except Exception as e:
                print("Error in socket emit:", str(e))

================
File: loup-garou-backend/.gitignore
================
.venv/
repomix-output.txt

================
File: loup-garou-backend/main.py
================
from server.app import create_app

app, socketio = create_app()

if __name__ == "__main__":
    socketio.run(app, host="0.0.0.0", port=5001, debug=True)

================
File: loup-garou-backend/requirements.txt
================
flask
flask_socketio
playsound
PyObjC

================
File: loup-garou-frontend/app/(tabs)/_layout.tsx
================
import { Tabs } from "expo-router";
import React from "react";
import { Platform } from "react-native";

import { HapticTab } from "@/components/HapticTab";
import { IconSymbol } from "@/components/ui/IconSymbol";
import TabBarBackground from "@/components/ui/TabBarBackground";
import { Colors } from "@/constants/Colors";
import { useColorScheme } from "@/hooks/useColorScheme";

export default function TabLayout() {
  const colorScheme = useColorScheme();

  return (
    <Tabs
      screenOptions={{
        tabBarActiveTintColor: Colors[colorScheme ?? "light"].tint,
        headerShown: false,
        tabBarButton: HapticTab,
        tabBarBackground: TabBarBackground,
        tabBarStyle: Platform.select({
          ios: {
            // Use a transparent background on iOS to show the blur effect
            position: "absolute",
          },
          default: {},
        }),
      }}
    >
      <Tabs.Screen
        name="index"
        options={{
          title: "Home",
          tabBarIcon: ({ color }) => (
            <IconSymbol size={28} name="house.fill" color={color} />
          ),
        }}
      />
    </Tabs>
  );
}

================
File: loup-garou-frontend/app/(tabs)/DayVote.tsx
================
import React, { useEffect, useState } from "react";
import { useRouter } from "expo-router";
import {
  SafeAreaView,
  Text,
  Button,
  FlatList,
  TouchableOpacity,
  View,
  Alert,
} from "react-native";
import axios from "axios";
import { socket } from "@/utils/sockets";
import { Player } from "../../types";
import { backendUrl } from "@/utils/config";
import { useLocalSearchParams } from "expo-router";

const DayVote = () => {
  const router = useRouter();
  const { player: playerString } = useLocalSearchParams() as { player: string };
  const [player, setPlayer] = useState<Player>(JSON.parse(playerString));
  const [playerSelection, setPlayerSelection] = useState<
    { name: string; sid: string }[]
  >([]);
  const [updatePlayers, setUpdatePlayers] = useState(false);
  const [playerHasVoted, setPlayerHasVoted] = useState(false);

  useEffect(() => {
    if (playerString) {
      setPlayer(JSON.parse(playerString));
      const newPlayer = JSON.parse(playerString);
      console.log("Player string", newPlayer);
    }
  }, [playerString]);

  useEffect(() => {
    const getAllPlayers = async () => {
      try {
        const response = await axios.get(`${backendUrl}/players`);
        const filteredPlayers = response.data.players
          .filter((item: { is_alive: boolean }) => item.is_alive)
          .filter((item: { sid: string }) => item.sid !== player.sid);
        setPlayerSelection(filteredPlayers);
        setUpdatePlayers(false);
      } catch (error) {
        console.error(error);
      }
    };

    getAllPlayers();
  }, [updatePlayers]);

  const handleVote = (sid: string) => {
    setPlayerHasVoted(true);
    socket.emit("vote_kill", { sid });
    //router.push({
    //  pathname: "/(tabs)/GameInterface",
    //  params: { player: JSON.stringify(player) },
    //});
  };

  const renderPlayer = ({ item }: { item: { name: string; sid: string } }) => (
    <View className="flex-row justify-between items-center p-2 bg-white my-1 rounded-lg">
      <Text className="text-lg">{item.name}</Text>
      <Button
        title="Vote"
        disabled={playerHasVoted}
        onPress={() => handleVote(item.sid)}
      />
    </View>
  );

  return (
    <SafeAreaView className="flex-1 bg-gray-900 p-4">
      <Text className="text-white text-center text-2xl mb-4">
        Choose a player to vote for killing:
      </Text>
      {playerSelection && (
        <FlatList
          data={playerSelection}
          renderItem={renderPlayer}
          keyExtractor={(item) => item.sid}
          className="text-white"
        />
      )}
    </SafeAreaView>
  );
};

export default DayVote;

================
File: loup-garou-frontend/app/(tabs)/Death.tsx
================
import React from "react";
import { SafeAreaView, Text, TouchableOpacity, View } from "react-native";
import { useRouter } from "expo-router";

const DeathScreen: React.FC = () => {
  return (
    <SafeAreaView className="flex-1 bg-gray-900 items-center justify-center">
      <View className="w-80 h-80 bg-gradient-to-br from-red-600 to-red-900 rounded-xl items-center justify-center p-6 shadow-xl border border-gray-200">
        <Text className="text-white text-3xl font-bold mb-4 text-center">
          Vous etes mort, pas le droit de parler !
        </Text>
      </View>
    </SafeAreaView>
  );
};

export default DeathScreen;

================
File: loup-garou-frontend/app/(tabs)/GameInterface.tsx
================
import { Text, View, TouchableOpacity, Button, Modal } from "react-native";
import { SafeAreaView } from "react-native-safe-area-context";
import { useLocalSearchParams, useRouter } from "expo-router";
import React, { useState, useEffect } from "react";
import { Player } from "../../types";
import { getRoleDescription } from "../../constants/roles";
import { socket } from "@/utils/sockets.js";
import Cupidon from "@/components/roles/Cupidon";
import Hunter from "@/components/roles/Hunter";
import LoveAlert from "./LoveAlert";
import WitchHeal from "./WitchHeal";
import WitchKill from "./WitchKill";
import * as Haptics from "expo-haptics";

const GameInterface: React.FC = () => {
  const router = useRouter();

  const [player, setPlayer] = useState<Player | null>(null);
  const [showDescription, setShowDescription] = useState(false);
  const [showCupidon, setShowCupidon] = useState(false);
  const [showHunter, setShowHunter] = useState(false);
  const [isInLove, setIsInLove] = useState(false);
  const [loverName, setLoverName] = useState("");
  const [showWitchHeal, setShowWitch] = useState(false);
  const [werewolfTarget, setWerewolfTarget] = useState("");
  const [showWitchKillModal, setShowWitchKillModal] = useState(false);
  const [showWitchKill, setShowWitchKill] = useState(false);

  const { player: playerString } = useLocalSearchParams() as { player: string };

  const handleCardPress = () => {
    setShowDescription(!showDescription);
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
  };

  useEffect(() => {
    if (playerString) {
      console.log("Player string is", playerString);
      const parsedPlayer: Player = JSON.parse(playerString);
      setPlayer(parsedPlayer);
    }
  }, []);

  useEffect(() => {
    console.log("Werewolf target is", werewolfTarget);
    if (werewolfTarget) {
      console.log("Setting show werewolf to true");
      setShowWitch(true);
    }
  }, [werewolfTarget]);

  useEffect(() => {
    const handleCupidonChoice = () => {
      setShowCupidon(true);
    };

    const handleIsInLove = (data: { lover: string }) => {
      setIsInLove(true);
      setLoverName(data.lover);
      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium)
        .then(() => console.log("Haptic feedback triggered"))
        .catch((error) =>
          console.error("Error triggering haptic feedback", error),
        );
    };

    const handleDeath = () => {
      cleanup();
      router.push("/(tabs)/Death");
    };

    const handleSeerChoice = () => {
      router.push("/(tabs)/Seer");
    };

    const handleWitchHeel = (data: { victim: string }) => {
      const victim = data.victim;
      setWerewolfTarget(victim);
    };

    const handleDayVote = () => {
      router.push({
        pathname: "/(tabs)/DayVote",
        params: { player: JSON.stringify(player) },
      });
    };

    const handleWerewolfWakeUp = () => {
      if (player) {
        try {
          router.push({
            pathname: "/(tabs)/Werewolf",
            params: { player: JSON.stringify(player) },
          });
          console.log("Router push completed");
        } catch (error) {
          console.error("Navigation error:", error);
        }
      }
    };
    const handleWitchKill = () => {
      setShowWitchKillModal(true);
    };

    const cleanup = () => {
      socket.off("cupidon_choice", handleCupidonChoice);
      socket.off("alert_lovers", handleIsInLove);
      socket.off("witch_heel", handleWitchHeel);
      socket.off("alert_dead", handleDeath);
      socket.off("werewolf_wake_up", handleWerewolfWakeUp);
      socket.off("day_vote", handleDayVote);
      socket.off("witch_kill", handleWitchKill);
      //socket.off("seer_choice", handleSeerChoice);
    };

    socket.once("cupidon_choice", handleCupidonChoice);
    socket.once("alert_lovers", handleIsInLove);
    socket.on("witch_heal", handleWitchHeel);
    socket.on("alert_dead", handleDeath);
    socket.on("witch_kill", handleWitchKill);
    socket.on("werewolf_wake_up", handleWerewolfWakeUp);
    socket.on("day_vote", handleDayVote);
    //socket.on("seer_choice", handleSeerChoice);

    return () => {
      cleanup();
    };
  }, [player]);

  useEffect(() => {
    if (player && showWitchKill) {
      try {
        router.push({
          pathname: "/(tabs)/WitchKill",
          params: { player: JSON.stringify(player) },
        });
      } catch (error) {
        console.error("Navigation error:", error);
      }
    }
  }, [showWitchKill]);

  const handleShowWitchKillModal = (choice: string) => {
    if (choice === "yes") {
      setShowWitchKill(true);
      setShowWitchKillModal(false);
    } else {
      setShowWitchKillModal(false);
      socket.emit("witch_no_kill");
    }
  };

  return (
    <SafeAreaView className="flex-1 bg-gray-900 items-center justify-center">
      <Text className="text-white text-2xl mb-5">Game Interface</Text>
      <Text className="text-white text-lg mb-5">Player: {player?.name}</Text>

      <TouchableOpacity
        onPress={handleCardPress}
        className="active:scale-95 transform transition-all"
      >
        <View className="w-72 h-96 bg-gradient-to-br from-white to-gray-100 rounded-xl items-center justify-between p-6 shadow-xl border border-gray-200">
          <View className="w-full flex items-center">
            {!showDescription ? (
              <>
                <View className="w-16 h-16 bg-gray-900 rounded-full mb-4 items-center justify-center">
                  <Text className="text-white text-2xl">?</Text>
                </View>
                <Text className="text-gray-800 text-lg font-medium text-center">
                  Appuyez sur la carte pour révéler votre rôle
                </Text>
              </>
            ) : (
              <>
                <Text className="text-white text-2xl font-bold mb-4">
                  {player?.role?.toUpperCase()}
                </Text>
                <View className="border-t border-gray-200 w-full pt-4">
                  <Text className="text-gray-400 text-lg text-center leading-relaxed">
                    {player?.role ? getRoleDescription(player.role) : ""}
                  </Text>
                </View>
              </>
            )}
          </View>
        </View>

        {loverName && (
          <LoveAlert
            visible={isInLove}
            onClose={() => {
              setIsInLove(false);
              socket.emit("lover_alert_closed");
              socket.emit("lover_alert_closed"); // TODO: Remove this line this is for testing purposes since we only have one player
            }}
            loverName={loverName}
          />
        )}

        {player && (
          <>
            <Cupidon
              visible={showCupidon}
              onClose={() => setShowCupidon(false)}
              cupidonName={player.name}
            />
            <Hunter
              visible={showHunter}
              onClose={() => setShowHunter(false)}
              hunterName={player.name}
            />
            <WitchHeal
              visible={showWitchHeal}
              onClose={() => setShowWitch(false)}
              victim={werewolfTarget}
            />
          </>
        )}
        {showWitchKillModal && (
          <Modal
            visible={showWitchKillModal}
            animationType="slide"
            transparent={true}
            onRequestClose={() => setShowWitchKillModal(false)}
          >
            <View className="flex-1 justify-center items-center bg-gray-50/50 bg-opacity-50">
              <View className="bg-white p-6 rounded-lg shadow-lg w-80">
                <Text className="text-black text-xl mb-4">
                  Voulez-vous tuer quelqu'un?
                </Text>
                <View className="flex-row justify-between">
                  <TouchableOpacity
                    onPress={() => handleShowWitchKillModal("yes")}
                    className="bg-red-500 p-3 rounded-lg"
                  >
                    <Text className="text-white">Oui</Text>
                  </TouchableOpacity>
                  <TouchableOpacity
                    onPress={() => handleShowWitchKillModal("no")}
                    className="bg-green-500 p-3 rounded-lg"
                  >
                    <Text className="text-white">Non</Text>
                  </TouchableOpacity>
                </View>
              </View>
            </View>
          </Modal>
        )}
      </TouchableOpacity>
    </SafeAreaView>
  );
};

export default GameInterface;

================
File: loup-garou-frontend/app/(tabs)/index.tsx
================
import axios from "axios";
import { useState, useEffect } from "react";
import { Link, useRouter } from "expo-router";
import { SafeAreaView } from "react-native-safe-area-context";
import { View, Text, TextInput, Button, ImageBackground } from "react-native";
import { Player } from "../../types";
import { socket } from "@/utils/sockets.js";

import "../../global.css";

export default function HomeScreen() {
  const router = useRouter();
  const [name, setName] = useState("");

  const handleJoinGame = () => {
    socket.emit("add_player", { name });
    socket.on("player_data", (playerData) => {
      router.push({
        pathname: "/(tabs)/waiting-room",
        params: { player: JSON.stringify(playerData) },
      });
    });
  };

  return (
    <ImageBackground
      source={require("../../assets/images/background-app-3.jpeg")}
      className="flex-1"
    >
      <SafeAreaView className="flex-1 justify-end pb-24 items-center">
        <View className="w-4/5 items-center bg-opacity-50 p-5 rounded-lg">
          <Text className="text-2xl text-white mb-5">Werewolf Game</Text>
          <TextInput
            className="w-full p-2 border border-gray-400 rounded mb-5 bg-white"
            placeholder="Enter your name"
            value={name}
            onChangeText={setName}
          />
          <Button title="Join Game" onPress={handleJoinGame} />
        </View>
      </SafeAreaView>
    </ImageBackground>
  );
}

================
File: loup-garou-frontend/app/(tabs)/LoveAlert.tsx
================
import React from "react";
import { SafeAreaView, Text, Button, Modal, View } from "react-native";
import { useState, useEffect } from "react";
import { socket } from "@/utils/sockets.js";

const LoveAlert = ({
  visible,
  onClose,
  loverName,
}: {
  visible: boolean;
  onClose: () => void;
  loverName: string;
}) => {
  const [isDisabled, setIsDisabled] = useState(true);

  useEffect(() => {
    socket.on("lover_can_close", () => {
      setIsDisabled(false);
    });
  }, []);
  return (
    <Modal visible={visible} animationType="slide" onRequestClose={onClose}>
      <SafeAreaView className="flex-1 bg-gray-900 items-center justify-center">
        <View className="w-72 h-96 bg-white rounded-lg items-center justify-center shadow-lg p-5">
          <Text className="text-black text-2xl mb-5">Love Alert</Text>
          <Text className="text-black text-lg mb-2">
            Vous etes en couple avec {loverName}!
          </Text>
          <Button title="Close" onPress={onClose} disabled={isDisabled} />
        </View>
      </SafeAreaView>
    </Modal>
  );
};

export default LoveAlert;

================
File: loup-garou-frontend/app/(tabs)/Seer.tsx
================
import React, { useEffect, useState } from "react";
import { useRouter } from "expo-router";
import {
  SafeAreaView,
  Text,
  Button,
  FlatList,
  TouchableOpacity,
  Modal,
  View,
  Animated,
} from "react-native";
import axios from "axios";
import { socket } from "../../utils/sockets";
import { Player } from "../../types";
import { backendUrl } from "@/utils/config";

const Seer = ({ seerName }: { visible: boolean; seerName: string }) => {
  const router = useRouter();
  const [players, setPlayers] = useState<{ name: string; sid: string }[]>([]);
  const [selectedPlayer, setSelectedPlayer] = useState<string | null>(null);
  const [playerRole, setPlayerRole] = useState<string | null>(null);
  const [fadeAnim] = useState(new Animated.Value(0));
  const [visible, setVisible] = useState(true);
  const [confirmPressed, setConfirmPressed] = useState(false);

  useEffect(() => {
    const fetchPlayers = async () => {
      try {
        const response = await axios.get(`${backendUrl}/players`);
        const allPlayers = response.data.players;
        setPlayers(
          allPlayers.filter((player: Player) => player.name !== seerName),
        );
      } catch (error) {
        console.error("Error fetching players:", error);
      }
    };
    fetchPlayers();
  }, []);

  const handlePlayerSelection = (sid: string) => {
    setSelectedPlayer(sid);
    setPlayerRole(null);
  };

  const handleSeerAction = async () => {
    if (selectedPlayer) {
      socket.emit("seer_check", selectedPlayer);

      socket.once("role_reveal", (data: { role: string }) => {
        setPlayerRole(data.role);
        Animated.timing(fadeAnim, {
          toValue: 1,
          duration: 500,
          useNativeDriver: true,
        }).start();
      });
      setConfirmPressed(true);
    }
  };

  const handleOnClose = () => {
    console.log("closing seer modal");
    setVisible(false);
    router.push("/(tabs)/GameInterface");
  };

  const renderPlayer = ({ item }: { item: { name: string; sid: string } }) => {
    return (
      <TouchableOpacity
        onPress={() => handlePlayerSelection(item.sid)}
        style={{
          padding: 10,
          backgroundColor: selectedPlayer === item.sid ? "lightblue" : "white",
          marginVertical: 5,
          borderRadius: 5,
          borderWidth: 1,
          borderColor: "#ccc",
        }}
        disabled={confirmPressed}
      >
        <Text>{item.name}</Text>
      </TouchableOpacity>
    );
  };

  return (
    <Modal
      visible={visible}
      animationType="slide"
      onRequestClose={handleOnClose}
    >
      <SafeAreaView className="flex-1 p-5 bg-gray-100">
        <Text className="text-lg font-bold text-center my-2">
          Choisissez un joueur pour voir son rôle:
        </Text>
        <FlatList
          data={players}
          renderItem={renderPlayer}
          keyExtractor={(item) => item.sid}
        />
        {selectedPlayer && !playerRole && (
          <Button
            title="Voir le rôle du joueur"
            onPress={handleSeerAction}
            disabled={!selectedPlayer}
          />
        )}
        {playerRole && (
          <Animated.View
            style={{ opacity: fadeAnim }}
            className="mt-5 p-5 bg-white rounded shadow"
          >
            <Text className="text-lg font-bold text-center mb-2">
              The player's role is: {playerRole}
            </Text>
            <Button title="Confirm" onPress={handleOnClose} />
          </Animated.View>
        )}
      </SafeAreaView>
    </Modal>
  );
};

export default Seer;

================
File: loup-garou-frontend/app/(tabs)/test-page.tsx
================
import React, { useEffect, useState } from "react";
import { View, Text, TextInput, Button } from "react-native";
import { socket } from "@/utils/sockets";
import axios from "axios";

const TestSocketPage = () => {
  const [message, setMessage] = useState("");
  const [receivedMessage, setReceivedMessage] = useState("");

  useEffect(() => {
    socket.on("test_event", (data) => {
      setReceivedMessage(data.message);
    });

    return () => {
      socket.off("test_event");
    };
  }, []);

  const sendMessage = () => {
    socket.emit("test_event", { message });
  };

  const triggerServerEvent = async () => {
    try {
      const response = await axios.get(
        "backendUrl/trigger_test_event",
      );
      console.log(response.data.status);
    } catch (error) {
      console.error("Error triggering event:", error);
    }
  };

  return (
    <View className="flex-1 p-4 justify-center">
      <Text className="text-2xl mb-4 text-center">Socket.IO Test Page</Text>
      <TextInput
        className="h-10 border border-gray-400 mb-4 px-2"
        value={message}
        onChangeText={setMessage}
        placeholder="Enter message"
      />
      <Button title="Send Message" onPress={sendMessage} />
      <Button title="Trigger Server Event" onPress={triggerServerEvent} />
      <Text className="mt-4 text-lg text-center">
        Received Message: {receivedMessage}
      </Text>
    </View>
  );
};

export default TestSocketPage;

================
File: loup-garou-frontend/app/(tabs)/waiting-room.tsx
================
import React, { useEffect, useState } from "react";
import { SafeAreaView } from "react-native-safe-area-context";
import { Text, Button } from "react-native";
import axios from "axios";
import { useRouter } from "expo-router";
import { socket } from "@/utils/sockets.js";
import { Player } from "../../types";
import { useLocalSearchParams } from "expo-router";
import { backendUrl } from "@/utils/config";

const waitingRoom = () => {
  const { player: playerString } = useLocalSearchParams() as { player: string };
  const [player, setPlayer] = useState<Player>(JSON.parse(playerString));
  const [playerHasRole, setPlayerHasRole] = useState(false);

  const router = useRouter();
  const [players, setPlayers] = useState<Player[]>([]);
  const [startGame, setStartGame] = useState(false);
  const [updatePlayers, setUpdatePlayers] = useState(false);

  useEffect(() => {
    const getAllPlayers = async () => {
      try {
        const response = await axios.get(`${backendUrl}/players`);
        const playerData = response.data.players;
        setPlayers(playerData);
        console.log(players);
        setUpdatePlayers(false);
      } catch (error) {
        console.error(error);
      }
    };

    getAllPlayers();
  }, [updatePlayers]);

  useEffect(() => {
    socket.on("update_players_list", () => {
      setUpdatePlayers(true);
    });
  }, []);

  const assignRole = (data: { role: string }) => {
    const newPlayer = { ...player, role: data.role };
    setPlayer(newPlayer);
    setPlayerHasRole(true);
  };

  useEffect(() => {
    socket.on("role_assigned", (data) => {
      assignRole(data);
    });

    return () => {
      socket.off("assign_roles");
    };
  }, []);

  useEffect(() => {
    if (playerHasRole) {
      router.push({
        pathname: "/(tabs)/GameInterface",
        params: { player: JSON.stringify(player) },
      });
    }
  }, [playerHasRole]);

  return (
    <SafeAreaView>
      <Text className="text-white justify-center text-center">
        be patient dawg
      </Text>
      {players.length === 0 ? (
        <Text className="text-white justify-center text-center">
          You are the first player, waiting for others to join
        </Text>
      ) : (
        <Text className="text-white justify-center text-center">
          {players.map((player) => player.name).join(", ")} are waiting with you
        </Text>
      )}
      <Button
        title="Go to screen"
        onPress={() =>
          router.push({
            pathname: "/(tabs)/DayVote",
            params: { player: JSON.stringify(player) },
          })
        }
      />
    </SafeAreaView>
  );
};

export default waitingRoom;

================
File: loup-garou-frontend/app/(tabs)/Werewolf.tsx
================
import React, { useEffect, useState } from "react";
import { useRouter } from "expo-router";
import {
  SafeAreaView,
  Text,
  Button,
  FlatList,
  TouchableOpacity,
  View,
  Alert,
} from "react-native";
import axios from "axios";
import { socket } from "@/utils/sockets";
import { Player } from "../../types";
import { backendUrl } from "@/utils/config";
import { useLocalSearchParams } from "expo-router";

const Werewolf = () => {
  const router = useRouter();
  const { player: playerString } = useLocalSearchParams() as { player: string };
  const [player, setPlayer] = useState<Player>(JSON.parse(playerString));
  const [playerSelection, setPlayerSelection] = useState<
    { name: string; sid: string }[]
  >([]);
  const [selectedPlayer, setSelectedPlayer] = useState<string | null>(null);
  const [otherWerewolvesVote, setOtherWerewolvesVote] = useState<{
    [key: string]: string;
  }>({});
  const [totalWerewolves, setTotalWerewolves] = useState<number>(0);

  useEffect(() => {
    if (playerString) {
      setPlayer(JSON.parse(playerString));
    }
  }, [playerString]);

  useEffect(() => {
    const getAllPlayers = async () => {
      try {
        const response = await axios.get(`${backendUrl}/players`);
        const playerData = response.data.players;
        const werewolfCount = playerData.filter(
          (p: Player) => p.role === "werewolf",
        ).length;
        const werewolveSelection = playerData.filter(
          (p: Player) => p.role !== "werewolf",
        );
        setTotalWerewolves(werewolfCount);
        setPlayerSelection(werewolveSelection);
      } catch (error) {
        console.error(error);
      }
    };

    if (player) {
      getAllPlayers();
    }

    socket.on(
      "new_selection_count",
      (data: { werewolf: string; name: string; vote: string }) => {
        setOtherWerewolvesVote((prev) => {
          const newVotes = {
            ...prev,
            [data.werewolf]: data.vote,
          };

          return newVotes;
        });
      },
    );

    return () => {
      socket.off("new_selection_count");
    };
  }, [player, totalWerewolves]);

  useEffect(() => {
    const allVotesEqual = () => {
      const votes = Object.values(otherWerewolvesVote);
      if (votes.length === 0 || votes.length < totalWerewolves) return false;
      if (votes.every((vote) => vote === votes[0])) {
        socket.emit("werewolf_kill", votes[0]);
        console.log("All werewolves agree on killing", votes[0]);
        router.push({
          pathname: "/(tabs)/GameInterface",
          params: { player: JSON.stringify(player) },
        });
      }
    };

    allVotesEqual();
  }, [otherWerewolvesVote, playerSelection]);

  const togglePlayerSelection = (sid: string, name: string) => {
    setSelectedPlayer(sid);
    socket.emit("update_werewolf_selection_count", {
      werewolf: player.name,
      name: name,
      vote: sid,
    });
  };

  const handleWerewolfSelection = () => {
    const chosenPlayer = playerSelection.find((p) => p.sid === selectedPlayer);
    socket.emit("werewolf_kill", chosenPlayer);
    router.push({
      pathname: "/(tabs)/GameInterface",
      params: { player: JSON.stringify(player) },
    });
  };

  const getVoteCount = (sid: string): number => {
    return Object.values(otherWerewolvesVote).filter((vote) => vote === sid)
      .length;
  };

  const allWerewolvesAgree = () => {
    const votes = Object.values(otherWerewolvesVote);
    return votes.length > 0 && votes.every((vote) => vote === selectedPlayer);
  };

  const renderPlayer = ({ item }: { item: { name: string; sid: string } }) => {
    const voteCount = getVoteCount(item.sid);

    return (
      <TouchableOpacity
        onPress={() => togglePlayerSelection(item.sid, item.name)}
        style={{
          padding: 10,
          backgroundColor: selectedPlayer === item.sid ? "lightblue" : "white",
          marginVertical: 5,
          borderRadius: 8,
        }}
      >
        <View
          style={{
            flexDirection: "row",
            justifyContent: "space-between",
            alignItems: "center",
          }}
        >
          <Text style={{ fontSize: 16 }}>{item.name}</Text>
          <View
            style={{
              backgroundColor: "#e0e0e0",
              borderRadius: 12,
              padding: 4,
              minWidth: 24,
              alignItems: "center",
            }}
          >
            <Text style={{ fontSize: 14 }}>
              {voteCount}/{totalWerewolves}
            </Text>
          </View>
        </View>
      </TouchableOpacity>
    );
  };

  return (
    <SafeAreaView className="flex-1 bg-gray-900 h-full w-full">
      <Text className="text-white justify-center text-center text-xl mb-4">
        Choisissez un joueur à tuer:
      </Text>
      {playerSelection && (
        <FlatList
          data={playerSelection}
          renderItem={renderPlayer}
          keyExtractor={(item) => item.sid}
          className="text-white"
        />
      )}
      <Button
        title="Confirm Selection"
        onPress={handleWerewolfSelection}
        disabled={!allWerewolvesAgree()}
      />
    </SafeAreaView>
  );
};

export default Werewolf;

================
File: loup-garou-frontend/app/(tabs)/WitchHeal.tsx
================
import React from "react";
import { SafeAreaView, Text, Button, Modal, View } from "react-native";
import { useState, useEffect } from "react";
import { socket } from "@/utils/sockets.js";

const WitchHeal = ({
  visible,
  victim,
  onClose,
}: {
  visible: boolean;
  victim: string;
  onClose: () => void;
}) => {
  const handleChoice = (choice: string) => {
    choice === "yes"
      ? socket.emit("witch_heal_victim")
      : socket.emit("witch_no_heal");
    onClose();
  };

  return (
    <Modal visible={visible} animationType="slide">
      <SafeAreaView className="flex-1 bg-gray-900 items-center justify-center">
        <View className="w-80 h-96 bg-white rounded-lg items-center justify-center shadow-lg p-5">
          <Text className="text-black text-2xl mb-5">Guérison</Text>
          <Text className="text-black text-lg mb-2">
            Les loup-garous ont tué {victim}! Voulez-vous utiliser votre pouvoir
            de guérison?
          </Text>
          <View className="flex flex-row justify-between w-full">
            <Button title="Oui" onPress={() => handleChoice("yes")} />
            <Button title="Non" onPress={() => handleChoice("no")} />
          </View>
        </View>
      </SafeAreaView>
    </Modal>
  );
};

export default WitchHeal;

================
File: loup-garou-frontend/app/(tabs)/WitchKill.tsx
================
import React, { useEffect, useState } from "react";
import { useRouter } from "expo-router";
import {
  SafeAreaView,
  Text,
  Button,
  FlatList,
  TouchableOpacity,
  View,
  Alert,
} from "react-native";
import axios from "axios";
import { socket } from "@/utils/sockets";
import { Player } from "../../types";
import { backendUrl } from "@/utils/config";
import { useLocalSearchParams } from "expo-router";

const WitchKill = () => {
  const router = useRouter();
  const { player: playerString } = useLocalSearchParams() as { player: string };
  const [player, setPlayer] = useState<Player>(JSON.parse(playerString));
  const [playerSelection, setPlayerSelection] = useState<
    { name: string; sid: string }[]
  >([]);

  useEffect(() => {
    if (playerString) {
      setPlayer(JSON.parse(playerString));
    }
  }, [playerString]);

  useEffect(() => {
    const getAllPlayers = async () => {
      try {
        const response = await axios.get(`${backendUrl}/players`);
        const playerData = response.data.players;
        const filteredPlayers = playerData.filter(
          (p: Player) => p.role !== "witch",
        );
        setPlayerSelection(filteredPlayers);
      } catch (error) {
        console.error(error);
      }
    };

    if (player) {
      getAllPlayers();
    }
  }, [player]);

  const handleWitchKill = (sid: string, name: string) => {
    socket.emit("witch_kill_victim", { sid, name });
    router.push({
      pathname: "/(tabs)/GameInterface",
      params: { player: JSON.stringify(player) },
    });
  };

  const handleNoKill = () => {
    router.push({
      pathname: "/(tabs)/GameInterface",
      params: { player: JSON.stringify(player) },
    });
  };

  const renderPlayer = ({ item }: { item: { name: string; sid: string } }) => (
    <View className="flex-row justify-between items-center p-2 bg-white my-1 rounded-lg">
      <Text className="text-lg">{item.name}</Text>
      <Button
        title="Kill"
        onPress={() => handleWitchKill(item.sid, item.name)}
      />
    </View>
  );

  return (
    <SafeAreaView className="flex-1 bg-gray-900 p-4">
      <Text className="text-white text-center text-2xl mb-4">
        Choose a player to kill:
      </Text>
      {playerSelection && (
        <FlatList
          data={playerSelection}
          renderItem={renderPlayer}
          keyExtractor={(item) => item.sid}
          className="text-white"
        />
      )}
    </SafeAreaView>
  );
};

export default WitchKill;

================
File: loup-garou-frontend/app/_layout.tsx
================
import {
  DarkTheme,
  DefaultTheme,
  ThemeProvider,
} from "@react-navigation/native";
import { useFonts } from "expo-font";
import { Stack } from "expo-router";
import * as SplashScreen from "expo-splash-screen";
import { StatusBar } from "expo-status-bar";
import { useEffect } from "react";

import { useColorScheme } from "@/hooks/useColorScheme";

// Prevent the splash screen from auto-hiding before asset loading is complete.
SplashScreen.preventAutoHideAsync();

export default function RootLayout() {
  const colorScheme = useColorScheme();
  const [loaded] = useFonts({
    SpaceMono: require("../assets/fonts/SpaceMono-Regular.ttf"),
  });

  useEffect(() => {
    if (loaded) {
      SplashScreen.hideAsync();
    }
  }, [loaded]);

  if (!loaded) {
    return null;
  }

  return (
    <ThemeProvider value={colorScheme === "dark" ? DarkTheme : DefaultTheme}>
      <Stack>
        <Stack.Screen name="(tabs)" options={{ headerShown: false }} />
        <Stack.Screen name="+not-found" />
      </Stack>
    </ThemeProvider>
  );
}

================
File: loup-garou-frontend/app/+not-found.tsx
================
import { Link, Stack } from 'expo-router';
import { StyleSheet } from 'react-native';

import { ThemedText } from '@/components/ThemedText';
import { ThemedView } from '@/components/ThemedView';

export default function NotFoundScreen() {
  return (
    <>
      <Stack.Screen options={{ title: 'Oops!' }} />
      <ThemedView style={styles.container}>
        <ThemedText type="title">This screen doesn't exist.</ThemedText>
        <Link href="/" style={styles.link}>
          <ThemedText type="link">Go to home screen!</ThemedText>
        </Link>
      </ThemedView>
    </>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    padding: 20,
  },
  link: {
    marginTop: 15,
    paddingVertical: 15,
  },
});

================
File: loup-garou-frontend/components/__tests__/__snapshots__/ThemedText-test.tsx.snap
================
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`renders correctly 1`] = `
<Text
  style={
    [
      {
        "color": "#11181C",
      },
      {
        "fontSize": 16,
        "lineHeight": 24,
      },
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
    ]
  }
>
  Snapshot test!
</Text>
`;

================
File: loup-garou-frontend/components/__tests__/ThemedText-test.tsx
================
import * as React from 'react';
import renderer from 'react-test-renderer';

import { ThemedText } from '../ThemedText';

it(`renders correctly`, () => {
  const tree = renderer.create(<ThemedText>Snapshot test!</ThemedText>).toJSON();

  expect(tree).toMatchSnapshot();
});

================
File: loup-garou-frontend/components/roles/Cupidon.tsx
================
import React, { useEffect, useState } from "react";
import { useRouter } from "expo-router";
import {
  SafeAreaView,
  Text,
  Button,
  FlatList,
  TouchableOpacity,
  Modal,
  View,
} from "react-native";
import axios from "axios";
import { socket } from "../../utils/sockets";
import { Player } from "../../types";
import { backendUrl } from "@/utils/config";

const Cupidon = ({
  visible,
  onClose,
  cupidonName,
}: {
  visible: boolean;
  onClose: () => void;
  cupidonName: string;
}) => {
  const router = useRouter();

  const [players, setPlayers] = useState<{ name: string; sid: string }[]>([]);
  const [selectedPlayers, setSelectedPlayers] = useState<string[]>([]);

  useEffect(() => {
    const fetchPlayers = async () => {
      try {
        const response = await axios.get(`${backendUrl}/players`);
        const allPlayers = response.data.players;
        setPlayers(
          allPlayers.filter((player: Player) => player.name !== cupidonName),
        );
      } catch (error) {
        console.error("Error fetching players:", error);
      }
    };

    fetchPlayers();
  }, []);

  const togglePlayerSelection = (sid: string) => {
    setSelectedPlayers((prevSelected) => {
      if (prevSelected.includes(sid)) {
        return prevSelected.filter((id) => id !== sid);
      } else if (prevSelected.length < 2) {
        return [...prevSelected, sid];
      } else {
        return prevSelected;
      }
    });
  };

  const handleCupidonSelection = (selectedPlayers: string[]) => {
    const chosenPlayers = players.filter((player) =>
      selectedPlayers.includes(player.sid),
    );
    socket.emit("cupidon_selection_complete", chosenPlayers);
    onClose();
    router.push("/(tabs)/GameInterface");
  };

  const renderPlayer = ({ item }: { item: { name: string; sid: string } }) => {
    return (
      <TouchableOpacity
        onPress={() => togglePlayerSelection(item.sid)}
        style={{
          padding: 10,
          backgroundColor: selectedPlayers.includes(item.sid)
            ? "lightblue"
            : "white",
          marginVertical: 5,
        }}
      >
        <Text>{item.name}</Text>
      </TouchableOpacity>
    );
  };

  return (
    <Modal visible={visible} animationType="slide" onRequestClose={onClose}>
      <SafeAreaView>
        <Text className="text-white justify-center text-center">
          Choose two players:
        </Text>

        <FlatList
          data={players}
          renderItem={renderPlayer}
          keyExtractor={(item) => item.sid}
        />
        <Button
          title="Confirm Selection"
          onPress={() => handleCupidonSelection(selectedPlayers)}
          disabled={selectedPlayers.length !== 2}
        />
      </SafeAreaView>
    </Modal>
  );
};

export default Cupidon;

================
File: loup-garou-frontend/components/roles/Hunter.tsx
================
import React, { useEffect, useState } from "react";
import { useRouter } from "expo-router";
import {
  SafeAreaView,
  Text,
  Button,
  FlatList,
  TouchableOpacity,
  Modal,
  View,
} from "react-native";
import axios from "axios";
import { socket } from "../../utils/sockets";
import { Player } from "../../types";
import { backendUrl } from "@/utils/config";

const Hunter = ({
  visible,
  onClose,
  hunterName,
}: {
  visible: boolean;
  onClose: () => void;
  hunterName: string;
}) => {
  const router = useRouter();
  const [players, setPlayers] = useState<{ name: string; sid: string }[]>([]);
  const [selectedPlayer, setSelectedPlayer] = useState<string | null>(null);

  useEffect(() => {
    const fetchPlayers = async () => {
      try {
        const response = await axios.get(`${backendUrl}/players`);
        const allPlayers = response.data.players;
        setPlayers(
          allPlayers.filter((player: Player) => player.name !== hunterName),
        );
      } catch (error) {
        console.error("Error fetching players:", error);
      }
    };
    fetchPlayers();
  }, []);

  const togglePlayerSelection = (sid: string) => {
    setSelectedPlayer(selectedPlayer === sid ? null : sid);
  };

  const handleHunterSelection = (selectedPlayer: string) => {
    const chosenPlayer = players.find(
      (player) => player.sid === selectedPlayer,
    );
    socket.emit("hunter_selection", chosenPlayer);
    onClose();
    router.push("/(tabs)/GameInterface");
  };

  const renderPlayer = ({ item }: { item: { name: string; sid: string } }) => {
    return (
      <TouchableOpacity
        onPress={() => togglePlayerSelection(item.sid)}
        style={{
          padding: 10,
          backgroundColor: selectedPlayer === item.sid ? "lightblue" : "white",
          marginVertical: 5,
        }}
      >
        <Text>{item.name}</Text>
      </TouchableOpacity>
    );
  };

  return (
    <Modal visible={visible} animationType="slide" onRequestClose={onClose}>
      <SafeAreaView>
        <Text className="text-white justify-center text-center">
          Choose a player to take down with you:
        </Text>
        <FlatList
          data={players}
          renderItem={renderPlayer}
          keyExtractor={(item) => item.sid}
        />
        <Button
          title="Confirm Selection"
          onPress={() =>
            selectedPlayer && handleHunterSelection(selectedPlayer)
          }
          disabled={!selectedPlayer}
        />
      </SafeAreaView>
    </Modal>
  );
};

export default Hunter;

================
File: loup-garou-frontend/components/ui/IconSymbol.ios.tsx
================
import { SymbolView, SymbolViewProps, SymbolWeight } from 'expo-symbols';
import { StyleProp, ViewStyle } from 'react-native';

export function IconSymbol({
  name,
  size = 24,
  color,
  style,
  weight = 'regular',
}: {
  name: SymbolViewProps['name'];
  size?: number;
  color: string;
  style?: StyleProp<ViewStyle>;
  weight?: SymbolWeight;
}) {
  return (
    <SymbolView
      weight={weight}
      tintColor={color}
      resizeMode="scaleAspectFit"
      name={name}
      style={[
        {
          width: size,
          height: size,
        },
        style,
      ]}
    />
  );
}

================
File: loup-garou-frontend/components/ui/IconSymbol.tsx
================
// This file is a fallback for using MaterialIcons on Android and web.

import MaterialIcons from '@expo/vector-icons/MaterialIcons';
import { SymbolWeight } from 'expo-symbols';
import React from 'react';
import { OpaqueColorValue, StyleProp, ViewStyle } from 'react-native';

// Add your SFSymbol to MaterialIcons mappings here.
const MAPPING = {
  // See MaterialIcons here: https://icons.expo.fyi
  // See SF Symbols in the SF Symbols app on Mac.
  'house.fill': 'home',
  'paperplane.fill': 'send',
  'chevron.left.forwardslash.chevron.right': 'code',
  'chevron.right': 'chevron-right',
} as Partial<
  Record<
    import('expo-symbols').SymbolViewProps['name'],
    React.ComponentProps<typeof MaterialIcons>['name']
  >
>;

export type IconSymbolName = keyof typeof MAPPING;

/**
 * An icon component that uses native SFSymbols on iOS, and MaterialIcons on Android and web. This ensures a consistent look across platforms, and optimal resource usage.
 *
 * Icon `name`s are based on SFSymbols and require manual mapping to MaterialIcons.
 */
export function IconSymbol({
  name,
  size = 24,
  color,
  style,
}: {
  name: IconSymbolName;
  size?: number;
  color: string | OpaqueColorValue;
  style?: StyleProp<ViewStyle>;
  weight?: SymbolWeight;
}) {
  return <MaterialIcons color={color} size={size} name={MAPPING[name]} style={style} />;
}

================
File: loup-garou-frontend/components/ui/TabBarBackground.ios.tsx
================
import { useBottomTabBarHeight } from '@react-navigation/bottom-tabs';
import { BlurView } from 'expo-blur';
import { StyleSheet } from 'react-native';
import { useSafeAreaInsets } from 'react-native-safe-area-context';

export default function BlurTabBarBackground() {
  return (
    <BlurView
      // System chrome material automatically adapts to the system's theme
      // and matches the native tab bar appearance on iOS.
      tint="systemChromeMaterial"
      intensity={100}
      style={StyleSheet.absoluteFill}
    />
  );
}

export function useBottomTabOverflow() {
  const tabHeight = useBottomTabBarHeight();
  const { bottom } = useSafeAreaInsets();
  return tabHeight - bottom;
}

================
File: loup-garou-frontend/components/ui/TabBarBackground.tsx
================
// This is a shim for web and Android where the tab bar is generally opaque.
export default undefined;

export function useBottomTabOverflow() {
  return 0;
}

================
File: loup-garou-frontend/components/Collapsible.tsx
================
import { PropsWithChildren, useState } from 'react';
import { StyleSheet, TouchableOpacity } from 'react-native';

import { ThemedText } from '@/components/ThemedText';
import { ThemedView } from '@/components/ThemedView';
import { IconSymbol } from '@/components/ui/IconSymbol';
import { Colors } from '@/constants/Colors';
import { useColorScheme } from '@/hooks/useColorScheme';

export function Collapsible({ children, title }: PropsWithChildren & { title: string }) {
  const [isOpen, setIsOpen] = useState(false);
  const theme = useColorScheme() ?? 'light';

  return (
    <ThemedView>
      <TouchableOpacity
        style={styles.heading}
        onPress={() => setIsOpen((value) => !value)}
        activeOpacity={0.8}>
        <IconSymbol
          name="chevron.right"
          size={18}
          weight="medium"
          color={theme === 'light' ? Colors.light.icon : Colors.dark.icon}
          style={{ transform: [{ rotate: isOpen ? '90deg' : '0deg' }] }}
        />

        <ThemedText type="defaultSemiBold">{title}</ThemedText>
      </TouchableOpacity>
      {isOpen && <ThemedView style={styles.content}>{children}</ThemedView>}
    </ThemedView>
  );
}

const styles = StyleSheet.create({
  heading: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 6,
  },
  content: {
    marginTop: 6,
    marginLeft: 24,
  },
});

================
File: loup-garou-frontend/components/ExternalLink.tsx
================
import { Link } from 'expo-router';
import { openBrowserAsync } from 'expo-web-browser';
import { type ComponentProps } from 'react';
import { Platform } from 'react-native';

type Props = Omit<ComponentProps<typeof Link>, 'href'> & { href: string };

export function ExternalLink({ href, ...rest }: Props) {
  return (
    <Link
      target="_blank"
      {...rest}
      href={href}
      onPress={async (event) => {
        if (Platform.OS !== 'web') {
          // Prevent the default behavior of linking to the default browser on native.
          event.preventDefault();
          // Open the link in an in-app browser.
          await openBrowserAsync(href);
        }
      }}
    />
  );
}

================
File: loup-garou-frontend/components/HapticTab.tsx
================
import { BottomTabBarButtonProps } from '@react-navigation/bottom-tabs';
import { PlatformPressable } from '@react-navigation/elements';
import * as Haptics from 'expo-haptics';

export function HapticTab(props: BottomTabBarButtonProps) {
  return (
    <PlatformPressable
      {...props}
      onPressIn={(ev) => {
        if (process.env.EXPO_OS === 'ios') {
          // Add a soft haptic feedback when pressing down on the tabs.
          Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
        }
        props.onPressIn?.(ev);
      }}
    />
  );
}

================
File: loup-garou-frontend/components/HelloWave.tsx
================
import { useEffect } from 'react';
import { StyleSheet } from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withTiming,
  withRepeat,
  withSequence,
} from 'react-native-reanimated';

import { ThemedText } from '@/components/ThemedText';

export function HelloWave() {
  const rotationAnimation = useSharedValue(0);

  useEffect(() => {
    rotationAnimation.value = withRepeat(
      withSequence(withTiming(25, { duration: 150 }), withTiming(0, { duration: 150 })),
      4 // Run the animation 4 times
    );
  }, []);

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [{ rotate: `${rotationAnimation.value}deg` }],
  }));

  return (
    <Animated.View style={animatedStyle}>
      <ThemedText style={styles.text}>👋</ThemedText>
    </Animated.View>
  );
}

const styles = StyleSheet.create({
  text: {
    fontSize: 28,
    lineHeight: 32,
    marginTop: -6,
  },
});

================
File: loup-garou-frontend/components/ParallaxScrollView.tsx
================
import type { PropsWithChildren, ReactElement } from 'react';
import { StyleSheet } from 'react-native';
import Animated, {
  interpolate,
  useAnimatedRef,
  useAnimatedStyle,
  useScrollViewOffset,
} from 'react-native-reanimated';

import { ThemedView } from '@/components/ThemedView';
import { useBottomTabOverflow } from '@/components/ui/TabBarBackground';
import { useColorScheme } from '@/hooks/useColorScheme';

const HEADER_HEIGHT = 250;

type Props = PropsWithChildren<{
  headerImage: ReactElement;
  headerBackgroundColor: { dark: string; light: string };
}>;

export default function ParallaxScrollView({
  children,
  headerImage,
  headerBackgroundColor,
}: Props) {
  const colorScheme = useColorScheme() ?? 'light';
  const scrollRef = useAnimatedRef<Animated.ScrollView>();
  const scrollOffset = useScrollViewOffset(scrollRef);
  const bottom = useBottomTabOverflow();
  const headerAnimatedStyle = useAnimatedStyle(() => {
    return {
      transform: [
        {
          translateY: interpolate(
            scrollOffset.value,
            [-HEADER_HEIGHT, 0, HEADER_HEIGHT],
            [-HEADER_HEIGHT / 2, 0, HEADER_HEIGHT * 0.75]
          ),
        },
        {
          scale: interpolate(scrollOffset.value, [-HEADER_HEIGHT, 0, HEADER_HEIGHT], [2, 1, 1]),
        },
      ],
    };
  });

  return (
    <ThemedView style={styles.container}>
      <Animated.ScrollView
        ref={scrollRef}
        scrollEventThrottle={16}
        scrollIndicatorInsets={{ bottom }}
        contentContainerStyle={{ paddingBottom: bottom }}>
        <Animated.View
          style={[
            styles.header,
            { backgroundColor: headerBackgroundColor[colorScheme] },
            headerAnimatedStyle,
          ]}>
          {headerImage}
        </Animated.View>
        <ThemedView style={styles.content}>{children}</ThemedView>
      </Animated.ScrollView>
    </ThemedView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    height: HEADER_HEIGHT,
    overflow: 'hidden',
  },
  content: {
    flex: 1,
    padding: 32,
    gap: 16,
    overflow: 'hidden',
  },
});

================
File: loup-garou-frontend/components/ThemedText.tsx
================
import { Text, type TextProps, StyleSheet } from 'react-native';

import { useThemeColor } from '@/hooks/useThemeColor';

export type ThemedTextProps = TextProps & {
  lightColor?: string;
  darkColor?: string;
  type?: 'default' | 'title' | 'defaultSemiBold' | 'subtitle' | 'link';
};

export function ThemedText({
  style,
  lightColor,
  darkColor,
  type = 'default',
  ...rest
}: ThemedTextProps) {
  const color = useThemeColor({ light: lightColor, dark: darkColor }, 'text');

  return (
    <Text
      style={[
        { color },
        type === 'default' ? styles.default : undefined,
        type === 'title' ? styles.title : undefined,
        type === 'defaultSemiBold' ? styles.defaultSemiBold : undefined,
        type === 'subtitle' ? styles.subtitle : undefined,
        type === 'link' ? styles.link : undefined,
        style,
      ]}
      {...rest}
    />
  );
}

const styles = StyleSheet.create({
  default: {
    fontSize: 16,
    lineHeight: 24,
  },
  defaultSemiBold: {
    fontSize: 16,
    lineHeight: 24,
    fontWeight: '600',
  },
  title: {
    fontSize: 32,
    fontWeight: 'bold',
    lineHeight: 32,
  },
  subtitle: {
    fontSize: 20,
    fontWeight: 'bold',
  },
  link: {
    lineHeight: 30,
    fontSize: 16,
    color: '#0a7ea4',
  },
});

================
File: loup-garou-frontend/components/ThemedView.tsx
================
import { View, type ViewProps } from 'react-native';

import { useThemeColor } from '@/hooks/useThemeColor';

export type ThemedViewProps = ViewProps & {
  lightColor?: string;
  darkColor?: string;
};

export function ThemedView({ style, lightColor, darkColor, ...otherProps }: ThemedViewProps) {
  const backgroundColor = useThemeColor({ light: lightColor, dark: darkColor }, 'background');

  return <View style={[{ backgroundColor }, style]} {...otherProps} />;
}

================
File: loup-garou-frontend/constants/Colors.ts
================
/**
 * Below are the colors that are used in the app. The colors are defined in the light and dark mode.
 * There are many other ways to style your app. For example, [Nativewind](https://www.nativewind.dev/), [Tamagui](https://tamagui.dev/), [unistyles](https://reactnativeunistyles.vercel.app), etc.
 */

const tintColorLight = '#0a7ea4';
const tintColorDark = '#fff';

export const Colors = {
  light: {
    text: '#11181C',
    background: '#fff',
    tint: tintColorLight,
    icon: '#687076',
    tabIconDefault: '#687076',
    tabIconSelected: tintColorLight,
  },
  dark: {
    text: '#ECEDEE',
    background: '#151718',
    tint: tintColorDark,
    icon: '#9BA1A6',
    tabIconDefault: '#9BA1A6',
    tabIconSelected: tintColorDark,
  },
};

================
File: loup-garou-frontend/constants/roles.ts
================
export interface Role {
  name: string;
  description: string;
}

export const roles: { [key: string]: Role } = {
  werewolf: {
    name: "Loup-Garou",
    description:
      "Chaque nuit, votez avec les autres loups-garous pour dévorer un villageois",
  },
  villager: {
    name: "Villageois",
    description:
      "Votez pendant la journée pour éliminer les loups-garous suspects",
  },
  seer: {
    name: "Voyante",
    description:
      "Chaque nuit, inspectez un joueur pour découvrir s'il est un loup-garou",
  },
  cupid: {
    name: "Cupidon",
    description:
      "La première nuit, choisissez deux joueurs qui tomberont amoureux. Si l'un meurt, l'autre meurt aussi.",
  },
  hunter: {
    name: "Chasseur",
    description:
      "Si vous mourez, vous pouvez immédiatement tuer un autre joueur en utilisant votre dernière balle",
  },
  witch: {
    name: "Sorcière",
    description:
      "Vous avez deux potions : une pour sauver un joueur tué par les loups-garous, une pour éliminer un joueur. Utilisable une seule fois chacune",
  },
  littleGirl: {
    name: "Petite Fille",
    description:
      "Chaque nuit, vous pouvez espionner les loups-garous, mais attention à ne pas vous faire repérer",
  },
};

export function getRoleDescription(roleName: string): string | undefined {
  const role = roles[roleName];
  return role ? role.description : undefined;
}

================
File: loup-garou-frontend/hooks/useColorScheme.ts
================
export { useColorScheme } from 'react-native';

================
File: loup-garou-frontend/hooks/useColorScheme.web.ts
================
import { useEffect, useState } from 'react';
import { useColorScheme as useRNColorScheme } from 'react-native';

/**
 * To support static rendering, this value needs to be re-calculated on the client side for web
 */
export function useColorScheme() {
  const [hasHydrated, setHasHydrated] = useState(false);

  useEffect(() => {
    setHasHydrated(true);
  }, []);

  const colorScheme = useRNColorScheme();

  if (hasHydrated) {
    return colorScheme;
  }

  return 'light';
}

================
File: loup-garou-frontend/hooks/useThemeColor.ts
================
/**
 * Learn more about light and dark modes:
 * https://docs.expo.dev/guides/color-schemes/
 */

import { Colors } from '@/constants/Colors';
import { useColorScheme } from '@/hooks/useColorScheme';

export function useThemeColor(
  props: { light?: string; dark?: string },
  colorName: keyof typeof Colors.light & keyof typeof Colors.dark
) {
  const theme = useColorScheme() ?? 'light';
  const colorFromProps = props[theme];

  if (colorFromProps) {
    return colorFromProps;
  } else {
    return Colors[theme][colorName];
  }
}

================
File: loup-garou-frontend/scripts/reset-project.js
================
#!/usr/bin/env node

/**
 * This script is used to reset the project to a blank state.
 * It moves the /app, /components, /hooks, /scripts, and /constants directories to /app-example and creates a new /app directory with an index.tsx and _layout.tsx file.
 * You can remove the `reset-project` script from package.json and safely delete this file after running it.
 */

const fs = require("fs");
const path = require("path");

const root = process.cwd();
const oldDirs = ["app", "components", "hooks", "constants", "scripts"];
const newDir = "app-example";
const newAppDir = "app";
const newDirPath = path.join(root, newDir);

const indexContent = `import { Text, View } from "react-native";

export default function Index() {
  return (
    <View
      style={{
        flex: 1,
        justifyContent: "center",
        alignItems: "center",
      }}
    >
      <Text>Edit app/index.tsx to edit this screen.</Text>
    </View>
  );
}
`;

const layoutContent = `import { Stack } from "expo-router";

export default function RootLayout() {
  return <Stack />;
}
`;

const moveDirectories = async () => {
  try {
    // Create the app-example directory
    await fs.promises.mkdir(newDirPath, { recursive: true });
    console.log(`📁 /${newDir} directory created.`);

    // Move old directories to new app-example directory
    for (const dir of oldDirs) {
      const oldDirPath = path.join(root, dir);
      const newDirPath = path.join(root, newDir, dir);
      if (fs.existsSync(oldDirPath)) {
        await fs.promises.rename(oldDirPath, newDirPath);
        console.log(`➡️ /${dir} moved to /${newDir}/${dir}.`);
      } else {
        console.log(`➡️ /${dir} does not exist, skipping.`);
      }
    }

    // Create new /app directory
    const newAppDirPath = path.join(root, newAppDir);
    await fs.promises.mkdir(newAppDirPath, { recursive: true });
    console.log("\n📁 New /app directory created.");

    // Create index.tsx
    const indexPath = path.join(newAppDirPath, "index.tsx");
    await fs.promises.writeFile(indexPath, indexContent);
    console.log("📄 app/index.tsx created.");

    // Create _layout.tsx
    const layoutPath = path.join(newAppDirPath, "_layout.tsx");
    await fs.promises.writeFile(layoutPath, layoutContent);
    console.log("📄 app/_layout.tsx created.");

    console.log("\n✅ Project reset complete. Next steps:");
    console.log(
      "1. Run `npx expo start` to start a development server.\n2. Edit app/index.tsx to edit the main screen.\n3. Delete the /app-example directory when you're done referencing it."
    );
  } catch (error) {
    console.error(`Error during script execution: ${error}`);
  }
};

moveDirectories();

================
File: loup-garou-frontend/utils/config.js
================
export const backendUrl = process.env.EXPO_PUBLIC_BACKEND_URL;

================
File: loup-garou-frontend/utils/sockets.js
================
import { io } from "socket.io-client";
import { backendUrl } from "@/utils/config";

export const socket = io(backendUrl, {
  autoConnect: true,
  transports: ["websocket"],
});

socket.on("connect", () => {
  console.log("Socket connected");
});

socket.on("connect_error", (error) => {
  console.log("Socket connection error:", error);
});

================
File: loup-garou-frontend/.env
================
EXPO_PUBLIC_BACKEND_URL=http://192.168.2.215:5001

================
File: loup-garou-frontend/.gitignore
================
# Learn more https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files

# dependencies
node_modules/

# Expo
.expo/
dist/
web-build/
expo-env.d.ts

# Native
*.orig.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision

# Metro
.metro-health-check*

# debug
npm-debug.*
yarn-debug.*
yarn-error.*

# macOS
.DS_Store
*.pem

# local env files
.env*.local

# typescript
*.tsbuildinfo

app-example
.env\n

================
File: loup-garou-frontend/app.json
================
{
  "expo": {
    "extra": {
      "ipAddr": "192.168.2.215"
    },
    "name": "loup-garou-frontend",
    "slug": "loup-garou-frontend",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/images/icon.png",
    "scheme": "myapp",
    "userInterfaceStyle": "automatic",
    "newArchEnabled": true,
    "ios": {
      "supportsTablet": true
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/images/adaptive-icon.png",
        "backgroundColor": "#ffffff"
      }
    },
    "web": {
      "bundler": "metro",
      "output": "static",
      "favicon": "./assets/images/favicon.png"
    },
    "plugins": [
      "expo-router",
      [
        "expo-splash-screen",
        {
          "image": "./assets/images/splash-icon.png",
          "imageWidth": 200,
          "resizeMode": "contain",
          "backgroundColor": "#ffffff"
        }
      ]
    ],
    "experiments": {
      "typedRoutes": true
    }
  }
}

================
File: loup-garou-frontend/babel.config.js
================
module.exports = function (api) {
  api.cache(true);
  return {
    presets: [
      ["babel-preset-expo", { jsxImportSource: "nativewind" }],
      "nativewind/babel",
    ],
  };
};

================
File: loup-garou-frontend/global.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

================
File: loup-garou-frontend/metro.config.js
================
const { getDefaultConfig } = require("expo/metro-config");
const { withNativeWind } = require('nativewind/metro');
const config = getDefaultConfig(__dirname)
module.exports = withNativeWind(config, { input: './global.css' })

================
File: loup-garou-frontend/nativewind-env.d.ts
================
/// <reference types="nativewind/types" />

// NOTE: This file should not be edited and should be committed with your source code. It is generated by NativeWind.

================
File: loup-garou-frontend/notes.txt
================
L'alert pour commencer le segment des loups garou ne marche pas
j'ai implementer une fonction emit test dans le frontend directement mais ca ne trigger pas
je ne sais pas pourquoi

================
File: loup-garou-frontend/package.json
================
{
  "name": "loup-garou-frontend",
  "main": "expo-router/entry",
  "version": "1.0.0",
  "scripts": {
    "start": "expo start",
    "reset-project": "node ./scripts/reset-project.js",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web",
    "test": "jest --watchAll",
    "lint": "expo lint"
  },
  "jest": {
    "preset": "jest-expo"
  },
  "dependencies": {
    "@expo/vector-icons": "^14.0.2",
    "@react-navigation/bottom-tabs": "^7.2.0",
    "@react-navigation/native": "^7.0.14",
    "axios": "^1.7.9",
    "expo": "~52.0.23",
    "expo-blur": "~14.0.1",
    "expo-constants": "~17.0.3",
    "expo-font": "~13.0.2",
    "expo-haptics": "~14.0.0",
    "expo-linking": "~7.0.3",
    "expo-router": "~4.0.15",
    "expo-splash-screen": "~0.29.18",
    "expo-status-bar": "~2.0.0",
    "expo-symbols": "~0.2.0",
    "expo-system-ui": "~4.0.6",
    "expo-web-browser": "~14.0.1",
    "nativewind": "^4.1.23",
    "react": "18.3.1",
    "react-dom": "18.3.1",
    "react-native": "0.76.5",
    "react-native-gesture-handler": "~2.20.2",
    "react-native-reanimated": "~3.16.1",
    "react-native-safe-area-context": "^4.14.1",
    "react-native-screens": "~4.4.0",
    "react-native-web": "~0.19.13",
    "react-native-websocket": "^1.0.2",
    "react-native-webview": "13.12.5",
    "socket.io-client": "^4.8.1",
    "tailwindcss": "^3.4.17"
  },
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@types/jest": "^29.5.12",
    "@types/react": "~18.3.12",
    "@types/react-test-renderer": "^18.3.0",
    "jest": "^29.2.1",
    "jest-expo": "~52.0.2",
    "react-test-renderer": "18.3.1",
    "typescript": "^5.3.3"
  },
  "private": true
}

================
File: loup-garou-frontend/README.md
================
# Welcome to your Expo app 👋

This is an [Expo](https://expo.dev) project created with [`create-expo-app`](https://www.npmjs.com/package/create-expo-app).

## Get started

1. Install dependencies

   ```bash
   npm install
   ```

2. Start the app

   ```bash
    npx expo start
   ```

In the output, you'll find options to open the app in a

- [development build](https://docs.expo.dev/develop/development-builds/introduction/)
- [Android emulator](https://docs.expo.dev/workflow/android-studio-emulator/)
- [iOS simulator](https://docs.expo.dev/workflow/ios-simulator/)
- [Expo Go](https://expo.dev/go), a limited sandbox for trying out app development with Expo

You can start developing by editing the files inside the **app** directory. This project uses [file-based routing](https://docs.expo.dev/router/introduction).

## Get a fresh project

When you're ready, run:

```bash
npm run reset-project
```

This command will move the starter code to the **app-example** directory and create a blank **app** directory where you can start developing.

## Learn more

To learn more about developing your project with Expo, look at the following resources:

- [Expo documentation](https://docs.expo.dev/): Learn fundamentals, or go into advanced topics with our [guides](https://docs.expo.dev/guides).
- [Learn Expo tutorial](https://docs.expo.dev/tutorial/introduction/): Follow a step-by-step tutorial where you'll create a project that runs on Android, iOS, and the web.

## Join the community

Join our community of developers creating universal apps.

- [Expo on GitHub](https://github.com/expo/expo): View our open source platform and contribute.
- [Discord community](https://chat.expo.dev): Chat with Expo users and ask questions.
# loup-garou

================
File: loup-garou-frontend/tailwind.config.js
================
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: ["./app/**/*.{js,jsx,ts,tsx}", 
"./components/**/*.{js,jsx,ts,tsx}"],
  presets: [require("nativewind/preset")],
  theme: {
    extend: {},
  },
  plugins: [],
}

================
File: loup-garou-frontend/tsconfig.json
================
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "paths": {
      "@/*": [
        "./*"
      ]
    }
  },
  "include": [
    "**/*.ts",
    "**/*.tsx",
    ".expo/types/**/*.ts",
    "expo-env.d.ts",
    "nativewind-env.d.ts"
  ]
}

================
File: loup-garou-frontend/types.ts
================
export type Player = {
  name: string;
  sid: string;
  role: string;
};

================
File: README.md
================
# loup-garou

Jeu du loup-garou pour jouer avec la famille sans avoir besoin de narrateur.

Expo pour frontend
Flask pour backend
